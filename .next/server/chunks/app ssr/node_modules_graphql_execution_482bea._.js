module.exports = {

"[project]/node_modules/graphql/execution/values.mjs (ecmascript, app ssr)": (({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__ }) => (() => {

__turbopack_esm__({
    "getArgumentValues": ()=>getArgumentValues,
    "getDirectiveValues": ()=>getDirectiveValues,
    "getVariableValues": ()=>getVariableValues
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$inspect$2e$mjs__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/graphql/jsutils/inspect.mjs (ecmascript, app ssr)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$keyMap$2e$mjs__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/graphql/jsutils/keyMap.mjs (ecmascript, app ssr)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$printPathArray$2e$mjs__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/graphql/jsutils/printPathArray.mjs (ecmascript, app ssr)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/graphql/error/GraphQLError.mjs (ecmascript, app ssr)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/graphql/language/kinds.mjs (ecmascript, app ssr)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$printer$2e$mjs__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/graphql/language/printer.mjs (ecmascript, app ssr)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/graphql/type/definition.mjs (ecmascript, app ssr)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$utilities$2f$coerceInputValue$2e$mjs__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/graphql/utilities/coerceInputValue.mjs (ecmascript, app ssr)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$utilities$2f$typeFromAST$2e$mjs__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/graphql/utilities/typeFromAST.mjs (ecmascript, app ssr)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$utilities$2f$valueFromAST$2e$mjs__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/graphql/utilities/valueFromAST.mjs (ecmascript, app ssr)");
"__TURBOPACK__ecmascript__hoisting__location__";
;
;
;
;
;
;
;
;
;
;
function getVariableValues(schema, varDefNodes, inputs, options) {
    const errors = [];
    const maxErrors = options === null || options === void 0 ? void 0 : options.maxErrors;
    try {
        const coerced = coerceVariableValues(schema, varDefNodes, inputs, (error)=>{
            if (maxErrors != null && errors.length >= maxErrors) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$28$ecmascript$29$__["GraphQLError"]('Too many errors processing variables, error limit reached. Execution aborted.');
            }
            errors.push(error);
        });
        if (errors.length === 0) {
            return {
                coerced
            };
        }
    } catch (error) {
        errors.push(error);
    }
    return {
        errors
    };
}
function coerceVariableValues(schema, varDefNodes, inputs, onError) {
    const coercedValues = {};
    for (const varDefNode of varDefNodes){
        const varName = varDefNode.variable.name.value;
        const varType = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$utilities$2f$typeFromAST$2e$mjs__$28$ecmascript$29$__["typeFromAST"](schema, varDefNode.type);
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$28$ecmascript$29$__["isInputType"](varType)) {
            // Must use input types for variables. This should be caught during
            // validation, however is checked again here for safety.
            const varTypeStr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$printer$2e$mjs__$28$ecmascript$29$__["print"](varDefNode.type);
            onError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$28$ecmascript$29$__["GraphQLError"](`Variable "$${varName}" expected value of type "${varTypeStr}" which cannot be used as an input type.`, {
                nodes: varDefNode.type
            }));
            continue;
        }
        if (!hasOwnProperty(inputs, varName)) {
            if (varDefNode.defaultValue) {
                coercedValues[varName] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$utilities$2f$valueFromAST$2e$mjs__$28$ecmascript$29$__["valueFromAST"](varDefNode.defaultValue, varType);
            } else if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$28$ecmascript$29$__["isNonNullType"](varType)) {
                const varTypeStr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$inspect$2e$mjs__$28$ecmascript$29$__["inspect"](varType);
                onError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$28$ecmascript$29$__["GraphQLError"](`Variable "$${varName}" of required type "${varTypeStr}" was not provided.`, {
                    nodes: varDefNode
                }));
            }
            continue;
        }
        const value = inputs[varName];
        if (value === null && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$28$ecmascript$29$__["isNonNullType"](varType)) {
            const varTypeStr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$inspect$2e$mjs__$28$ecmascript$29$__["inspect"](varType);
            onError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$28$ecmascript$29$__["GraphQLError"](`Variable "$${varName}" of non-null type "${varTypeStr}" must not be null.`, {
                nodes: varDefNode
            }));
            continue;
        }
        coercedValues[varName] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$utilities$2f$coerceInputValue$2e$mjs__$28$ecmascript$29$__["coerceInputValue"](value, varType, (path, invalidValue, error)=>{
            let prefix = `Variable "$${varName}" got invalid value ` + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$inspect$2e$mjs__$28$ecmascript$29$__["inspect"](invalidValue);
            if (path.length > 0) {
                prefix += ` at "${varName}${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$printPathArray$2e$mjs__$28$ecmascript$29$__["printPathArray"](path)}"`;
            }
            onError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$28$ecmascript$29$__["GraphQLError"](prefix + '; ' + error.message, {
                nodes: varDefNode,
                originalError: error
            }));
        });
    }
    return coercedValues;
}
function getArgumentValues(def, node, variableValues) {
    var _node$arguments;
    const coercedValues = {}; // FIXME: https://github.com/graphql/graphql-js/issues/2203
    /* c8 ignore next */ const argumentNodes = (_node$arguments = node.arguments) !== null && _node$arguments !== void 0 ? _node$arguments : [];
    const argNodeMap = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$keyMap$2e$mjs__$28$ecmascript$29$__["keyMap"](argumentNodes, (arg)=>arg.name.value);
    for (const argDef of def.args){
        const name = argDef.name;
        const argType = argDef.type;
        const argumentNode = argNodeMap[name];
        if (!argumentNode) {
            if (argDef.defaultValue !== undefined) {
                coercedValues[name] = argDef.defaultValue;
            } else if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$28$ecmascript$29$__["isNonNullType"](argType)) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$28$ecmascript$29$__["GraphQLError"](`Argument "${name}" of required type "${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$inspect$2e$mjs__$28$ecmascript$29$__["inspect"](argType)}" ` + 'was not provided.', {
                    nodes: node
                });
            }
            continue;
        }
        const valueNode = argumentNode.value;
        let isNull = valueNode.kind === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$28$ecmascript$29$__["Kind"].NULL;
        if (valueNode.kind === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$28$ecmascript$29$__["Kind"].VARIABLE) {
            const variableName = valueNode.name.value;
            if (variableValues == null || !hasOwnProperty(variableValues, variableName)) {
                if (argDef.defaultValue !== undefined) {
                    coercedValues[name] = argDef.defaultValue;
                } else if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$28$ecmascript$29$__["isNonNullType"](argType)) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$28$ecmascript$29$__["GraphQLError"](`Argument "${name}" of required type "${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$inspect$2e$mjs__$28$ecmascript$29$__["inspect"](argType)}" ` + `was provided the variable "$${variableName}" which was not provided a runtime value.`, {
                        nodes: valueNode
                    });
                }
                continue;
            }
            isNull = variableValues[variableName] == null;
        }
        if (isNull && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$28$ecmascript$29$__["isNonNullType"](argType)) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$28$ecmascript$29$__["GraphQLError"](`Argument "${name}" of non-null type "${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$inspect$2e$mjs__$28$ecmascript$29$__["inspect"](argType)}" ` + 'must not be null.', {
                nodes: valueNode
            });
        }
        const coercedValue = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$utilities$2f$valueFromAST$2e$mjs__$28$ecmascript$29$__["valueFromAST"](valueNode, argType, variableValues);
        if (coercedValue === undefined) {
            // Note: ValuesOfCorrectTypeRule validation should catch this before
            // execution. This is a runtime check to ensure execution does not
            // continue with an invalid argument value.
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$28$ecmascript$29$__["GraphQLError"](`Argument "${name}" has invalid value ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$printer$2e$mjs__$28$ecmascript$29$__["print"](valueNode)}.`, {
                nodes: valueNode
            });
        }
        coercedValues[name] = coercedValue;
    }
    return coercedValues;
}
function getDirectiveValues(directiveDef, node, variableValues) {
    var _node$directives;
    const directiveNode = (_node$directives = node.directives) === null || _node$directives === void 0 ? void 0 : _node$directives.find((directive)=>directive.name.value === directiveDef.name);
    if (directiveNode) {
        return getArgumentValues(directiveDef, directiveNode, variableValues);
    }
}
function hasOwnProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
}

})()),
"[project]/node_modules/graphql/execution/collectFields.mjs (ecmascript, app ssr)": (({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__ }) => (() => {

__turbopack_esm__({
    "collectFields": ()=>collectFields,
    "collectSubfields": ()=>collectSubfields
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/graphql/language/kinds.mjs (ecmascript, app ssr)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/graphql/type/definition.mjs (ecmascript, app ssr)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$directives$2e$mjs__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/graphql/type/directives.mjs (ecmascript, app ssr)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$utilities$2f$typeFromAST$2e$mjs__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/graphql/utilities/typeFromAST.mjs (ecmascript, app ssr)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$execution$2f$values$2e$mjs__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/graphql/execution/values.mjs (ecmascript, app ssr)");
"__TURBOPACK__ecmascript__hoisting__location__";
;
;
;
;
;
function collectFields(schema, fragments, variableValues, runtimeType, selectionSet) {
    const fields = new Map();
    collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, new Set());
    return fields;
}
function collectSubfields(schema, fragments, variableValues, returnType, fieldNodes) {
    const subFieldNodes = new Map();
    const visitedFragmentNames = new Set();
    for (const node of fieldNodes){
        if (node.selectionSet) {
            collectFieldsImpl(schema, fragments, variableValues, returnType, node.selectionSet, subFieldNodes, visitedFragmentNames);
        }
    }
    return subFieldNodes;
}
function collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, visitedFragmentNames) {
    for (const selection of selectionSet.selections){
        switch(selection.kind){
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$28$ecmascript$29$__["Kind"].FIELD:
                {
                    if (!shouldIncludeNode(variableValues, selection)) {
                        continue;
                    }
                    const name = getFieldEntryKey(selection);
                    const fieldList = fields.get(name);
                    if (fieldList !== undefined) {
                        fieldList.push(selection);
                    } else {
                        fields.set(name, [
                            selection
                        ]);
                    }
                    break;
                }
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$28$ecmascript$29$__["Kind"].INLINE_FRAGMENT:
                {
                    if (!shouldIncludeNode(variableValues, selection) || !doesFragmentConditionMatch(schema, selection, runtimeType)) {
                        continue;
                    }
                    collectFieldsImpl(schema, fragments, variableValues, runtimeType, selection.selectionSet, fields, visitedFragmentNames);
                    break;
                }
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$28$ecmascript$29$__["Kind"].FRAGMENT_SPREAD:
                {
                    const fragName = selection.name.value;
                    if (visitedFragmentNames.has(fragName) || !shouldIncludeNode(variableValues, selection)) {
                        continue;
                    }
                    visitedFragmentNames.add(fragName);
                    const fragment = fragments[fragName];
                    if (!fragment || !doesFragmentConditionMatch(schema, fragment, runtimeType)) {
                        continue;
                    }
                    collectFieldsImpl(schema, fragments, variableValues, runtimeType, fragment.selectionSet, fields, visitedFragmentNames);
                    break;
                }
        }
    }
}
/**
 * Determines if a field should be included based on the `@include` and `@skip`
 * directives, where `@skip` has higher precedence than `@include`.
 */ function shouldIncludeNode(variableValues, node) {
    const skip = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$execution$2f$values$2e$mjs__$28$ecmascript$29$__["getDirectiveValues"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$directives$2e$mjs__$28$ecmascript$29$__["GraphQLSkipDirective"], node, variableValues);
    if ((skip === null || skip === void 0 ? void 0 : skip.if) === true) {
        return false;
    }
    const include = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$execution$2f$values$2e$mjs__$28$ecmascript$29$__["getDirectiveValues"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$directives$2e$mjs__$28$ecmascript$29$__["GraphQLIncludeDirective"], node, variableValues);
    if ((include === null || include === void 0 ? void 0 : include.if) === false) {
        return false;
    }
    return true;
}
/**
 * Determines if a fragment is applicable to the given type.
 */ function doesFragmentConditionMatch(schema, fragment, type) {
    const typeConditionNode = fragment.typeCondition;
    if (!typeConditionNode) {
        return true;
    }
    const conditionalType = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$utilities$2f$typeFromAST$2e$mjs__$28$ecmascript$29$__["typeFromAST"](schema, typeConditionNode);
    if (conditionalType === type) {
        return true;
    }
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$28$ecmascript$29$__["isAbstractType"](conditionalType)) {
        return schema.isSubType(conditionalType, type);
    }
    return false;
}
/**
 * Implements the logic to compute the key of a given field's entry
 */ function getFieldEntryKey(node) {
    return node.alias ? node.alias.value : node.name.value;
}

})()),
"[project]/node_modules/graphql/execution/execute.mjs (ecmascript, app ssr)": (({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__ }) => (() => {

__turbopack_esm__({
    "assertValidExecutionArguments": ()=>assertValidExecutionArguments,
    "buildExecutionContext": ()=>buildExecutionContext,
    "buildResolveInfo": ()=>buildResolveInfo,
    "defaultFieldResolver": ()=>defaultFieldResolver,
    "defaultTypeResolver": ()=>defaultTypeResolver,
    "execute": ()=>execute,
    "executeSync": ()=>executeSync,
    "getFieldDef": ()=>getFieldDef
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$devAssert$2e$mjs__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/graphql/jsutils/devAssert.mjs (ecmascript, app ssr)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$inspect$2e$mjs__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/graphql/jsutils/inspect.mjs (ecmascript, app ssr)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$invariant$2e$mjs__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/graphql/jsutils/invariant.mjs (ecmascript, app ssr)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$isIterableObject$2e$mjs__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/graphql/jsutils/isIterableObject.mjs (ecmascript, app ssr)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$isObjectLike$2e$mjs__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/graphql/jsutils/isObjectLike.mjs (ecmascript, app ssr)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$isPromise$2e$mjs__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/graphql/jsutils/isPromise.mjs (ecmascript, app ssr)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$memoize3$2e$mjs__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/graphql/jsutils/memoize3.mjs (ecmascript, app ssr)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$Path$2e$mjs__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/graphql/jsutils/Path.mjs (ecmascript, app ssr)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$promiseForObject$2e$mjs__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/graphql/jsutils/promiseForObject.mjs (ecmascript, app ssr)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$promiseReduce$2e$mjs__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/graphql/jsutils/promiseReduce.mjs (ecmascript, app ssr)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/graphql/error/GraphQLError.mjs (ecmascript, app ssr)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$locatedError$2e$mjs__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/graphql/error/locatedError.mjs (ecmascript, app ssr)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$ast$2e$mjs__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/graphql/language/ast.mjs (ecmascript, app ssr)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/graphql/language/kinds.mjs (ecmascript, app ssr)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/graphql/type/definition.mjs (ecmascript, app ssr)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$introspection$2e$mjs__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/graphql/type/introspection.mjs (ecmascript, app ssr)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$validate$2e$mjs__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/graphql/type/validate.mjs (ecmascript, app ssr)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$execution$2f$collectFields$2e$mjs__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/graphql/execution/collectFields.mjs (ecmascript, app ssr)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$execution$2f$values$2e$mjs__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/graphql/execution/values.mjs (ecmascript, app ssr)");
"__TURBOPACK__ecmascript__hoisting__location__";
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
/**
 * A memoized collection of relevant subfields with regard to the return
 * type. Memoizing ensures the subfields are not repeatedly calculated, which
 * saves overhead when resolving lists of values.
 */ const collectSubfields = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$memoize3$2e$mjs__$28$ecmascript$29$__["memoize3"]((exeContext, returnType, fieldNodes)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$execution$2f$collectFields$2e$mjs__$28$ecmascript$29$__["collectSubfields"](exeContext.schema, exeContext.fragments, exeContext.variableValues, returnType, fieldNodes));
function execute(args) {
    // Temporary for v15 to v16 migration. Remove in v17
    arguments.length < 2 || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$devAssert$2e$mjs__$28$ecmascript$29$__["devAssert"](false, 'graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead.');
    const { schema, document, variableValues, rootValue } = args; // If arguments are missing or incorrect, throw an error.
    assertValidExecutionArguments(schema, document, variableValues); // If a valid execution context cannot be created due to incorrect arguments,
    // a "Response" with only errors is returned.
    const exeContext = buildExecutionContext(args); // Return early errors if execution context failed.
    if (!('schema' in exeContext)) {
        return {
            errors: exeContext
        };
    } // Return a Promise that will eventually resolve to the data described by
    // The "Response" section of the GraphQL specification.
    //
    // If errors are encountered while executing a GraphQL field, only that
    // field and its descendants will be omitted, and sibling fields will still
    // be executed. An execution which encounters errors will still result in a
    // resolved Promise.
    //
    // Errors from sub-fields of a NonNull type may propagate to the top level,
    // at which point we still log the error and null the parent field, which
    // in this case is the entire response.
    try {
        const { operation } = exeContext;
        const result = executeOperation(exeContext, operation, rootValue);
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$isPromise$2e$mjs__$28$ecmascript$29$__["isPromise"](result)) {
            return result.then((data)=>buildResponse(data, exeContext.errors), (error)=>{
                exeContext.errors.push(error);
                return buildResponse(null, exeContext.errors);
            });
        }
        return buildResponse(result, exeContext.errors);
    } catch (error) {
        exeContext.errors.push(error);
        return buildResponse(null, exeContext.errors);
    }
}
function executeSync(args) {
    const result = execute(args); // Assert that the execution was synchronous.
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$isPromise$2e$mjs__$28$ecmascript$29$__["isPromise"](result)) {
        throw new Error('GraphQL execution failed to complete synchronously.');
    }
    return result;
}
/**
 * Given a completed execution context and data, build the `{ errors, data }`
 * response defined by the "Response" section of the GraphQL specification.
 */ function buildResponse(data, errors) {
    return errors.length === 0 ? {
        data
    } : {
        errors,
        data
    };
}
function assertValidExecutionArguments(schema, document, rawVariableValues) {
    document || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$devAssert$2e$mjs__$28$ecmascript$29$__["devAssert"](false, 'Must provide document.'); // If the schema used for execution is invalid, throw an error.
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$validate$2e$mjs__$28$ecmascript$29$__["assertValidSchema"](schema); // Variables, if provided, must be an object.
    rawVariableValues == null || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$isObjectLike$2e$mjs__$28$ecmascript$29$__["isObjectLike"](rawVariableValues) || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$devAssert$2e$mjs__$28$ecmascript$29$__["devAssert"](false, 'Variables must be provided as an Object where each property is a variable value. Perhaps look to see if an unparsed JSON string was provided.');
}
function buildExecutionContext(args) {
    var _definition$name, _operation$variableDe;
    const { schema, document, rootValue, contextValue, variableValues: rawVariableValues, operationName, fieldResolver, typeResolver, subscribeFieldResolver } = args;
    let operation;
    const fragments = Object.create(null);
    for (const definition of document.definitions){
        switch(definition.kind){
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$28$ecmascript$29$__["Kind"].OPERATION_DEFINITION:
                if (operationName == null) {
                    if (operation !== undefined) {
                        return [
                            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$28$ecmascript$29$__["GraphQLError"]('Must provide operation name if query contains multiple operations.')
                        ];
                    }
                    operation = definition;
                } else if (((_definition$name = definition.name) === null || _definition$name === void 0 ? void 0 : _definition$name.value) === operationName) {
                    operation = definition;
                }
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$kinds$2e$mjs__$28$ecmascript$29$__["Kind"].FRAGMENT_DEFINITION:
                fragments[definition.name.value] = definition;
                break;
            default:
        }
    }
    if (!operation) {
        if (operationName != null) {
            return [
                new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$28$ecmascript$29$__["GraphQLError"](`Unknown operation named "${operationName}".`)
            ];
        }
        return [
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$28$ecmascript$29$__["GraphQLError"]('Must provide an operation.')
        ];
    } // FIXME: https://github.com/graphql/graphql-js/issues/2203
    /* c8 ignore next */ const variableDefinitions = (_operation$variableDe = operation.variableDefinitions) !== null && _operation$variableDe !== void 0 ? _operation$variableDe : [];
    const coercedVariableValues = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$execution$2f$values$2e$mjs__$28$ecmascript$29$__["getVariableValues"](schema, variableDefinitions, rawVariableValues !== null && rawVariableValues !== void 0 ? rawVariableValues : {}, {
        maxErrors: 50
    });
    if (coercedVariableValues.errors) {
        return coercedVariableValues.errors;
    }
    return {
        schema,
        fragments,
        rootValue,
        contextValue,
        operation,
        variableValues: coercedVariableValues.coerced,
        fieldResolver: fieldResolver !== null && fieldResolver !== void 0 ? fieldResolver : defaultFieldResolver,
        typeResolver: typeResolver !== null && typeResolver !== void 0 ? typeResolver : defaultTypeResolver,
        subscribeFieldResolver: subscribeFieldResolver !== null && subscribeFieldResolver !== void 0 ? subscribeFieldResolver : defaultFieldResolver,
        errors: []
    };
}
/**
 * Implements the "Executing operations" section of the spec.
 */ function executeOperation(exeContext, operation, rootValue) {
    const rootType = exeContext.schema.getRootType(operation.operation);
    if (rootType == null) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$28$ecmascript$29$__["GraphQLError"](`Schema is not configured to execute ${operation.operation} operation.`, {
            nodes: operation
        });
    }
    const rootFields = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$execution$2f$collectFields$2e$mjs__$28$ecmascript$29$__["collectFields"](exeContext.schema, exeContext.fragments, exeContext.variableValues, rootType, operation.selectionSet);
    const path = undefined;
    switch(operation.operation){
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$ast$2e$mjs__$28$ecmascript$29$__["OperationTypeNode"].QUERY:
            return executeFields(exeContext, rootType, rootValue, path, rootFields);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$ast$2e$mjs__$28$ecmascript$29$__["OperationTypeNode"].MUTATION:
            return executeFieldsSerially(exeContext, rootType, rootValue, path, rootFields);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$language$2f$ast$2e$mjs__$28$ecmascript$29$__["OperationTypeNode"].SUBSCRIPTION:
            // TODO: deprecate `subscribe` and move all logic here
            // Temporary solution until we finish merging execute and subscribe together
            return executeFields(exeContext, rootType, rootValue, path, rootFields);
    }
}
/**
 * Implements the "Executing selection sets" section of the spec
 * for fields that must be executed serially.
 */ function executeFieldsSerially(exeContext, parentType, sourceValue, path, fields) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$promiseReduce$2e$mjs__$28$ecmascript$29$__["promiseReduce"](fields.entries(), (results, [responseName, fieldNodes])=>{
        const fieldPath = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$Path$2e$mjs__$28$ecmascript$29$__["addPath"](path, responseName, parentType.name);
        const result = executeField(exeContext, parentType, sourceValue, fieldNodes, fieldPath);
        if (result === undefined) {
            return results;
        }
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$isPromise$2e$mjs__$28$ecmascript$29$__["isPromise"](result)) {
            return result.then((resolvedResult)=>{
                results[responseName] = resolvedResult;
                return results;
            });
        }
        results[responseName] = result;
        return results;
    }, Object.create(null));
}
/**
 * Implements the "Executing selection sets" section of the spec
 * for fields that may be executed in parallel.
 */ function executeFields(exeContext, parentType, sourceValue, path, fields) {
    const results = Object.create(null);
    let containsPromise = false;
    try {
        for (const [responseName, fieldNodes] of fields.entries()){
            const fieldPath = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$Path$2e$mjs__$28$ecmascript$29$__["addPath"](path, responseName, parentType.name);
            const result = executeField(exeContext, parentType, sourceValue, fieldNodes, fieldPath);
            if (result !== undefined) {
                results[responseName] = result;
                if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$isPromise$2e$mjs__$28$ecmascript$29$__["isPromise"](result)) {
                    containsPromise = true;
                }
            }
        }
    } catch (error) {
        if (containsPromise) {
            // Ensure that any promises returned by other fields are handled, as they may also reject.
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$promiseForObject$2e$mjs__$28$ecmascript$29$__["promiseForObject"](results).finally(()=>{
                throw error;
            });
        }
        throw error;
    } // If there are no promises, we can just return the object
    if (!containsPromise) {
        return results;
    } // Otherwise, results is a map from field name to the result of resolving that
    // field, which is possibly a promise. Return a promise that will return this
    // same map, but with any promises replaced with the values they resolved to.
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$promiseForObject$2e$mjs__$28$ecmascript$29$__["promiseForObject"](results);
}
/**
 * Implements the "Executing fields" section of the spec
 * In particular, this function figures out the value that the field returns by
 * calling its resolve function, then calls completeValue to complete promises,
 * serialize scalars, or execute the sub-selection-set for objects.
 */ function executeField(exeContext, parentType, source, fieldNodes, path) {
    var _fieldDef$resolve;
    const fieldDef = getFieldDef(exeContext.schema, parentType, fieldNodes[0]);
    if (!fieldDef) {
        return;
    }
    const returnType = fieldDef.type;
    const resolveFn = (_fieldDef$resolve = fieldDef.resolve) !== null && _fieldDef$resolve !== void 0 ? _fieldDef$resolve : exeContext.fieldResolver;
    const info = buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path); // Get the resolve function, regardless of if its result is normal or abrupt (error).
    try {
        // Build a JS object of arguments from the field.arguments AST, using the
        // variables scope to fulfill any variable references.
        // TODO: find a way to memoize, in case this field is within a List type.
        const args = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$execution$2f$values$2e$mjs__$28$ecmascript$29$__["getArgumentValues"](fieldDef, fieldNodes[0], exeContext.variableValues); // The resolve function's optional third argument is a context value that
        // is provided to every resolve function within an execution. It is commonly
        // used to represent an authenticated user, or request-specific caches.
        const contextValue = exeContext.contextValue;
        const result = resolveFn(source, args, contextValue, info);
        let completed;
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$isPromise$2e$mjs__$28$ecmascript$29$__["isPromise"](result)) {
            completed = result.then((resolved)=>completeValue(exeContext, returnType, fieldNodes, info, path, resolved));
        } else {
            completed = completeValue(exeContext, returnType, fieldNodes, info, path, result);
        }
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$isPromise$2e$mjs__$28$ecmascript$29$__["isPromise"](completed)) {
            // Note: we don't rely on a `catch` method, but we do expect "thenable"
            // to take a second callback for the error case.
            return completed.then(undefined, (rawError)=>{
                const error = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$locatedError$2e$mjs__$28$ecmascript$29$__["locatedError"](rawError, fieldNodes, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$Path$2e$mjs__$28$ecmascript$29$__["pathToArray"](path));
                return handleFieldError(error, returnType, exeContext);
            });
        }
        return completed;
    } catch (rawError) {
        const error = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$locatedError$2e$mjs__$28$ecmascript$29$__["locatedError"](rawError, fieldNodes, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$Path$2e$mjs__$28$ecmascript$29$__["pathToArray"](path));
        return handleFieldError(error, returnType, exeContext);
    }
}
function buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path) {
    // The resolve function's optional fourth argument is a collection of
    // information about the current execution state.
    return {
        fieldName: fieldDef.name,
        fieldNodes,
        returnType: fieldDef.type,
        parentType,
        path,
        schema: exeContext.schema,
        fragments: exeContext.fragments,
        rootValue: exeContext.rootValue,
        operation: exeContext.operation,
        variableValues: exeContext.variableValues
    };
}
function handleFieldError(error, returnType, exeContext) {
    // If the field type is non-nullable, then it is resolved without any
    // protection from errors, however it still properly locates the error.
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$28$ecmascript$29$__["isNonNullType"](returnType)) {
        throw error;
    } // Otherwise, error protection is applied, logging the error and resolving
    // a null value for this field if one is encountered.
    exeContext.errors.push(error);
    return null;
}
/**
 * Implements the instructions for completeValue as defined in the
 * "Value Completion" section of the spec.
 *
 * If the field type is Non-Null, then this recursively completes the value
 * for the inner type. It throws a field error if that completion returns null,
 * as per the "Nullability" section of the spec.
 *
 * If the field type is a List, then this recursively completes the value
 * for the inner type on each item in the list.
 *
 * If the field type is a Scalar or Enum, ensures the completed value is a legal
 * value of the type by calling the `serialize` method of GraphQL type
 * definition.
 *
 * If the field is an abstract type, determine the runtime type of the value
 * and then complete based on that type
 *
 * Otherwise, the field type expects a sub-selection set, and will complete the
 * value by executing all sub-selections.
 */ function completeValue(exeContext, returnType, fieldNodes, info, path, result) {
    // If result is an Error, throw a located error.
    if (result instanceof Error) {
        throw result;
    } // If field type is NonNull, complete for inner type, and throw field error
    // if result is null.
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$28$ecmascript$29$__["isNonNullType"](returnType)) {
        const completed = completeValue(exeContext, returnType.ofType, fieldNodes, info, path, result);
        if (completed === null) {
            throw new Error(`Cannot return null for non-nullable field ${info.parentType.name}.${info.fieldName}.`);
        }
        return completed;
    } // If result value is null or undefined then return null.
    if (result == null) {
        return null;
    } // If field type is List, complete each item in the list with the inner type
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$28$ecmascript$29$__["isListType"](returnType)) {
        return completeListValue(exeContext, returnType, fieldNodes, info, path, result);
    } // If field type is a leaf type, Scalar or Enum, serialize to a valid value,
    // returning null if serialization is not possible.
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$28$ecmascript$29$__["isLeafType"](returnType)) {
        return completeLeafValue(returnType, result);
    } // If field type is an abstract type, Interface or Union, determine the
    // runtime Object type and complete for that type.
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$28$ecmascript$29$__["isAbstractType"](returnType)) {
        return completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result);
    } // If field type is Object, execute and complete all sub-selections.
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$28$ecmascript$29$__["isObjectType"](returnType)) {
        return completeObjectValue(exeContext, returnType, fieldNodes, info, path, result);
    }
    /* c8 ignore next 6 */ // Not reachable, all possible output types have been considered.
    false || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$invariant$2e$mjs__$28$ecmascript$29$__["invariant"](false, 'Cannot complete value of unexpected output type: ' + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$inspect$2e$mjs__$28$ecmascript$29$__["inspect"](returnType));
}
/**
 * Complete a list value by completing each item in the list with the
 * inner type
 */ function completeListValue(exeContext, returnType, fieldNodes, info, path, result) {
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$isIterableObject$2e$mjs__$28$ecmascript$29$__["isIterableObject"](result)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$28$ecmascript$29$__["GraphQLError"](`Expected Iterable, but did not find one for field "${info.parentType.name}.${info.fieldName}".`);
    } // This is specified as a simple map, however we're optimizing the path
    // where the list contains no Promises by avoiding creating another Promise.
    const itemType = returnType.ofType;
    let containsPromise = false;
    const completedResults = Array.from(result, (item, index)=>{
        // No need to modify the info object containing the path,
        // since from here on it is not ever accessed by resolver functions.
        const itemPath = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$Path$2e$mjs__$28$ecmascript$29$__["addPath"](path, index, undefined);
        try {
            let completedItem;
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$isPromise$2e$mjs__$28$ecmascript$29$__["isPromise"](item)) {
                completedItem = item.then((resolved)=>completeValue(exeContext, itemType, fieldNodes, info, itemPath, resolved));
            } else {
                completedItem = completeValue(exeContext, itemType, fieldNodes, info, itemPath, item);
            }
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$isPromise$2e$mjs__$28$ecmascript$29$__["isPromise"](completedItem)) {
                containsPromise = true; // Note: we don't rely on a `catch` method, but we do expect "thenable"
                // to take a second callback for the error case.
                return completedItem.then(undefined, (rawError)=>{
                    const error = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$locatedError$2e$mjs__$28$ecmascript$29$__["locatedError"](rawError, fieldNodes, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$Path$2e$mjs__$28$ecmascript$29$__["pathToArray"](itemPath));
                    return handleFieldError(error, itemType, exeContext);
                });
            }
            return completedItem;
        } catch (rawError) {
            const error = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$locatedError$2e$mjs__$28$ecmascript$29$__["locatedError"](rawError, fieldNodes, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$Path$2e$mjs__$28$ecmascript$29$__["pathToArray"](itemPath));
            return handleFieldError(error, itemType, exeContext);
        }
    });
    return containsPromise ? Promise.all(completedResults) : completedResults;
}
/**
 * Complete a Scalar or Enum by serializing to a valid value, returning
 * null if serialization is not possible.
 */ function completeLeafValue(returnType, result) {
    const serializedResult = returnType.serialize(result);
    if (serializedResult == null) {
        throw new Error(`Expected \`${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$inspect$2e$mjs__$28$ecmascript$29$__["inspect"](returnType)}.serialize(${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$inspect$2e$mjs__$28$ecmascript$29$__["inspect"](result)})\` to ` + `return non-nullable value, returned: ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$inspect$2e$mjs__$28$ecmascript$29$__["inspect"](serializedResult)}`);
    }
    return serializedResult;
}
/**
 * Complete a value of an abstract type by determining the runtime object type
 * of that value, then complete the value for that type.
 */ function completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result) {
    var _returnType$resolveTy;
    const resolveTypeFn = (_returnType$resolveTy = returnType.resolveType) !== null && _returnType$resolveTy !== void 0 ? _returnType$resolveTy : exeContext.typeResolver;
    const contextValue = exeContext.contextValue;
    const runtimeType = resolveTypeFn(result, contextValue, info, returnType);
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$isPromise$2e$mjs__$28$ecmascript$29$__["isPromise"](runtimeType)) {
        return runtimeType.then((resolvedRuntimeType)=>completeObjectValue(exeContext, ensureValidRuntimeType(resolvedRuntimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result));
    }
    return completeObjectValue(exeContext, ensureValidRuntimeType(runtimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result);
}
function ensureValidRuntimeType(runtimeTypeName, exeContext, returnType, fieldNodes, info, result) {
    if (runtimeTypeName == null) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$28$ecmascript$29$__["GraphQLError"](`Abstract type "${returnType.name}" must resolve to an Object type at runtime for field "${info.parentType.name}.${info.fieldName}". Either the "${returnType.name}" type should provide a "resolveType" function or each possible type should provide an "isTypeOf" function.`, fieldNodes);
    } // releases before 16.0.0 supported returning `GraphQLObjectType` from `resolveType`
    // TODO: remove in 17.0.0 release
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$28$ecmascript$29$__["isObjectType"](runtimeTypeName)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$28$ecmascript$29$__["GraphQLError"]('Support for returning GraphQLObjectType from resolveType was removed in graphql-js@16.0.0 please return type name instead.');
    }
    if (typeof runtimeTypeName !== 'string') {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$28$ecmascript$29$__["GraphQLError"](`Abstract type "${returnType.name}" must resolve to an Object type at runtime for field "${info.parentType.name}.${info.fieldName}" with ` + `value ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$inspect$2e$mjs__$28$ecmascript$29$__["inspect"](result)}, received "${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$inspect$2e$mjs__$28$ecmascript$29$__["inspect"](runtimeTypeName)}".`);
    }
    const runtimeType = exeContext.schema.getType(runtimeTypeName);
    if (runtimeType == null) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$28$ecmascript$29$__["GraphQLError"](`Abstract type "${returnType.name}" was resolved to a type "${runtimeTypeName}" that does not exist inside the schema.`, {
            nodes: fieldNodes
        });
    }
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$definition$2e$mjs__$28$ecmascript$29$__["isObjectType"](runtimeType)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$28$ecmascript$29$__["GraphQLError"](`Abstract type "${returnType.name}" was resolved to a non-object type "${runtimeTypeName}".`, {
            nodes: fieldNodes
        });
    }
    if (!exeContext.schema.isSubType(returnType, runtimeType)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$28$ecmascript$29$__["GraphQLError"](`Runtime Object type "${runtimeType.name}" is not a possible type for "${returnType.name}".`, {
            nodes: fieldNodes
        });
    }
    return runtimeType;
}
/**
 * Complete an Object value by executing all sub-selections.
 */ function completeObjectValue(exeContext, returnType, fieldNodes, info, path, result) {
    // Collect sub-fields to execute to complete this value.
    const subFieldNodes = collectSubfields(exeContext, returnType, fieldNodes); // If there is an isTypeOf predicate function, call it with the
    // current result. If isTypeOf returns false, then raise an error rather
    // than continuing execution.
    if (returnType.isTypeOf) {
        const isTypeOf = returnType.isTypeOf(result, exeContext.contextValue, info);
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$isPromise$2e$mjs__$28$ecmascript$29$__["isPromise"](isTypeOf)) {
            return isTypeOf.then((resolvedIsTypeOf)=>{
                if (!resolvedIsTypeOf) {
                    throw invalidReturnTypeError(returnType, result, fieldNodes);
                }
                return executeFields(exeContext, returnType, result, path, subFieldNodes);
            });
        }
        if (!isTypeOf) {
            throw invalidReturnTypeError(returnType, result, fieldNodes);
        }
    }
    return executeFields(exeContext, returnType, result, path, subFieldNodes);
}
function invalidReturnTypeError(returnType, result, fieldNodes) {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$28$ecmascript$29$__["GraphQLError"](`Expected value of type "${returnType.name}" but got: ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$inspect$2e$mjs__$28$ecmascript$29$__["inspect"](result)}.`, {
        nodes: fieldNodes
    });
}
const defaultTypeResolver = function(value, contextValue, info, abstractType) {
    // First, look for `__typename`.
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$isObjectLike$2e$mjs__$28$ecmascript$29$__["isObjectLike"](value) && typeof value.__typename === 'string') {
        return value.__typename;
    } // Otherwise, test each possible type.
    const possibleTypes = info.schema.getPossibleTypes(abstractType);
    const promisedIsTypeOfResults = [];
    for(let i = 0; i < possibleTypes.length; i++){
        const type = possibleTypes[i];
        if (type.isTypeOf) {
            const isTypeOfResult = type.isTypeOf(value, contextValue, info);
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$isPromise$2e$mjs__$28$ecmascript$29$__["isPromise"](isTypeOfResult)) {
                promisedIsTypeOfResults[i] = isTypeOfResult;
            } else if (isTypeOfResult) {
                return type.name;
            }
        }
    }
    if (promisedIsTypeOfResults.length) {
        return Promise.all(promisedIsTypeOfResults).then((isTypeOfResults)=>{
            for(let i = 0; i < isTypeOfResults.length; i++){
                if (isTypeOfResults[i]) {
                    return possibleTypes[i].name;
                }
            }
        });
    }
};
const defaultFieldResolver = function(source, args, contextValue, info) {
    // ensure source is a value for which property access is acceptable.
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$isObjectLike$2e$mjs__$28$ecmascript$29$__["isObjectLike"](source) || typeof source === 'function') {
        const property = source[info.fieldName];
        if (typeof property === 'function') {
            return source[info.fieldName](args, contextValue, info);
        }
        return property;
    }
};
function getFieldDef(schema, parentType, fieldNode) {
    const fieldName = fieldNode.name.value;
    if (fieldName === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$introspection$2e$mjs__$28$ecmascript$29$__["SchemaMetaFieldDef"].name && schema.getQueryType() === parentType) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$introspection$2e$mjs__$28$ecmascript$29$__["SchemaMetaFieldDef"];
    } else if (fieldName === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$introspection$2e$mjs__$28$ecmascript$29$__["TypeMetaFieldDef"].name && schema.getQueryType() === parentType) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$introspection$2e$mjs__$28$ecmascript$29$__["TypeMetaFieldDef"];
    } else if (fieldName === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$introspection$2e$mjs__$28$ecmascript$29$__["TypeNameMetaFieldDef"].name) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$type$2f$introspection$2e$mjs__$28$ecmascript$29$__["TypeNameMetaFieldDef"];
    }
    return parentType.getFields()[fieldName];
}

})()),
"[project]/node_modules/graphql/execution/mapAsyncIterator.mjs (ecmascript, app ssr)": (({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__ }) => (() => {

/**
 * Given an AsyncIterable and a callback function, return an AsyncIterator
 * which produces values mapped via calling the callback function.
 */ __turbopack_esm__({
    "mapAsyncIterator": ()=>mapAsyncIterator
});
function mapAsyncIterator(iterable, callback) {
    const iterator = iterable[Symbol.asyncIterator]();
    async function mapResult(result) {
        if (result.done) {
            return result;
        }
        try {
            return {
                value: await callback(result.value),
                done: false
            };
        } catch (error) {
            /* c8 ignore start */ // FIXME: add test case
            if (typeof iterator.return === 'function') {
                try {
                    await iterator.return();
                } catch (_e) {
                /* ignore error */ }
            }
            throw error;
        /* c8 ignore stop */ }
    }
    return {
        async next () {
            return mapResult(await iterator.next());
        },
        async return () {
            // If iterator.return() does not exist, then type R must be undefined.
            return typeof iterator.return === 'function' ? mapResult(await iterator.return()) : {
                value: undefined,
                done: true
            };
        },
        async throw (error) {
            if (typeof iterator.throw === 'function') {
                return mapResult(await iterator.throw(error));
            }
            throw error;
        },
        [Symbol.asyncIterator] () {
            return this;
        }
    };
}

})()),
"[project]/node_modules/graphql/execution/subscribe.mjs (ecmascript, app ssr)": (({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__ }) => (() => {

__turbopack_esm__({
    "createSourceEventStream": ()=>createSourceEventStream,
    "subscribe": ()=>subscribe
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$devAssert$2e$mjs__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/graphql/jsutils/devAssert.mjs (ecmascript, app ssr)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$inspect$2e$mjs__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/graphql/jsutils/inspect.mjs (ecmascript, app ssr)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$isAsyncIterable$2e$mjs__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/graphql/jsutils/isAsyncIterable.mjs (ecmascript, app ssr)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$Path$2e$mjs__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/graphql/jsutils/Path.mjs (ecmascript, app ssr)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/graphql/error/GraphQLError.mjs (ecmascript, app ssr)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$locatedError$2e$mjs__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/graphql/error/locatedError.mjs (ecmascript, app ssr)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$execution$2f$collectFields$2e$mjs__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/graphql/execution/collectFields.mjs (ecmascript, app ssr)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$execution$2f$execute$2e$mjs__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/graphql/execution/execute.mjs (ecmascript, app ssr)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$execution$2f$mapAsyncIterator$2e$mjs__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/graphql/execution/mapAsyncIterator.mjs (ecmascript, app ssr)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$execution$2f$values$2e$mjs__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/graphql/execution/values.mjs (ecmascript, app ssr)");
"__TURBOPACK__ecmascript__hoisting__location__";
;
;
;
;
;
;
;
;
;
;
async function subscribe(args) {
    // Temporary for v15 to v16 migration. Remove in v17
    arguments.length < 2 || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$devAssert$2e$mjs__$28$ecmascript$29$__["devAssert"](false, 'graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead.');
    const resultOrStream = await createSourceEventStream(args);
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$isAsyncIterable$2e$mjs__$28$ecmascript$29$__["isAsyncIterable"](resultOrStream)) {
        return resultOrStream;
    } // For each payload yielded from a subscription, map it over the normal
    // GraphQL `execute` function, with `payload` as the rootValue.
    // This implements the "MapSourceToResponseEvent" algorithm described in
    // the GraphQL specification. The `execute` function provides the
    // "ExecuteSubscriptionEvent" algorithm, as it is nearly identical to the
    // "ExecuteQuery" algorithm, for which `execute` is also used.
    const mapSourceToResponse = (payload)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$execution$2f$execute$2e$mjs__$28$ecmascript$29$__["execute"]({
            ...args,
            rootValue: payload
        }); // Map every source value to a ExecutionResult value as described above.
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$execution$2f$mapAsyncIterator$2e$mjs__$28$ecmascript$29$__["mapAsyncIterator"](resultOrStream, mapSourceToResponse);
}
function toNormalizedArgs(args) {
    const firstArg = args[0];
    if (firstArg && 'document' in firstArg) {
        return firstArg;
    }
    return {
        schema: firstArg,
        // FIXME: when underlying TS bug fixed, see https://github.com/microsoft/TypeScript/issues/31613
        document: args[1],
        rootValue: args[2],
        contextValue: args[3],
        variableValues: args[4],
        operationName: args[5],
        subscribeFieldResolver: args[6]
    };
}
async function createSourceEventStream(...rawArgs) {
    const args = toNormalizedArgs(rawArgs);
    const { schema, document, variableValues } = args; // If arguments are missing or incorrectly typed, this is an internal
    // developer mistake which should throw an early error.
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$execution$2f$execute$2e$mjs__$28$ecmascript$29$__["assertValidExecutionArguments"](schema, document, variableValues); // If a valid execution context cannot be created due to incorrect arguments,
    // a "Response" with only errors is returned.
    const exeContext = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$execution$2f$execute$2e$mjs__$28$ecmascript$29$__["buildExecutionContext"](args); // Return early errors if execution context failed.
    if (!('schema' in exeContext)) {
        return {
            errors: exeContext
        };
    }
    try {
        const eventStream = await executeSubscription(exeContext); // Assert field returned an event stream, otherwise yield an error.
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$isAsyncIterable$2e$mjs__$28$ecmascript$29$__["isAsyncIterable"](eventStream)) {
            throw new Error('Subscription field must return Async Iterable. ' + `Received: ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$inspect$2e$mjs__$28$ecmascript$29$__["inspect"](eventStream)}.`);
        }
        return eventStream;
    } catch (error) {
        // If it GraphQLError, report it as an ExecutionResult, containing only errors and no data.
        // Otherwise treat the error as a system-class error and re-throw it.
        if (error instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$28$ecmascript$29$__["GraphQLError"]) {
            return {
                errors: [
                    error
                ]
            };
        }
        throw error;
    }
}
async function executeSubscription(exeContext) {
    const { schema, fragments, operation, variableValues, rootValue } = exeContext;
    const rootType = schema.getSubscriptionType();
    if (rootType == null) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$28$ecmascript$29$__["GraphQLError"]('Schema is not configured to execute subscription operation.', {
            nodes: operation
        });
    }
    const rootFields = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$execution$2f$collectFields$2e$mjs__$28$ecmascript$29$__["collectFields"](schema, fragments, variableValues, rootType, operation.selectionSet);
    const [responseName, fieldNodes] = [
        ...rootFields.entries()
    ][0];
    const fieldDef = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$execution$2f$execute$2e$mjs__$28$ecmascript$29$__["getFieldDef"](schema, rootType, fieldNodes[0]);
    if (!fieldDef) {
        const fieldName = fieldNodes[0].name.value;
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$GraphQLError$2e$mjs__$28$ecmascript$29$__["GraphQLError"](`The subscription field "${fieldName}" is not defined.`, {
            nodes: fieldNodes
        });
    }
    const path = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$Path$2e$mjs__$28$ecmascript$29$__["addPath"](undefined, responseName, rootType.name);
    const info = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$execution$2f$execute$2e$mjs__$28$ecmascript$29$__["buildResolveInfo"](exeContext, fieldDef, fieldNodes, rootType, path);
    try {
        var _fieldDef$subscribe;
        // Implements the "ResolveFieldEventStream" algorithm from GraphQL specification.
        // It differs from "ResolveFieldValue" due to providing a different `resolveFn`.
        // Build a JS object of arguments from the field.arguments AST, using the
        // variables scope to fulfill any variable references.
        const args = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$execution$2f$values$2e$mjs__$28$ecmascript$29$__["getArgumentValues"](fieldDef, fieldNodes[0], variableValues); // The resolve function's optional third argument is a context value that
        // is provided to every resolve function within an execution. It is commonly
        // used to represent an authenticated user, or request-specific caches.
        const contextValue = exeContext.contextValue; // Call the `subscribe()` resolver or the default resolver to produce an
        // AsyncIterable yielding raw payloads.
        const resolveFn = (_fieldDef$subscribe = fieldDef.subscribe) !== null && _fieldDef$subscribe !== void 0 ? _fieldDef$subscribe : exeContext.subscribeFieldResolver;
        const eventStream = await resolveFn(rootValue, args, contextValue, info);
        if (eventStream instanceof Error) {
            throw eventStream;
        }
        return eventStream;
    } catch (error) {
        throw __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$error$2f$locatedError$2e$mjs__$28$ecmascript$29$__["locatedError"](error, fieldNodes, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$Path$2e$mjs__$28$ecmascript$29$__["pathToArray"](path));
    }
}

})()),
"[project]/node_modules/graphql/execution/index.mjs (ecmascript, app ssr)": (({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__ }) => (() => {

__turbopack_esm__({
    "createSourceEventStream": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$execution$2f$subscribe$2e$mjs__$28$ecmascript$29$__["createSourceEventStream"],
    "defaultFieldResolver": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$execution$2f$execute$2e$mjs__$28$ecmascript$29$__["defaultFieldResolver"],
    "defaultTypeResolver": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$execution$2f$execute$2e$mjs__$28$ecmascript$29$__["defaultTypeResolver"],
    "execute": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$execution$2f$execute$2e$mjs__$28$ecmascript$29$__["execute"],
    "executeSync": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$execution$2f$execute$2e$mjs__$28$ecmascript$29$__["executeSync"],
    "getArgumentValues": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$execution$2f$values$2e$mjs__$28$ecmascript$29$__["getArgumentValues"],
    "getDirectiveValues": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$execution$2f$values$2e$mjs__$28$ecmascript$29$__["getDirectiveValues"],
    "getVariableValues": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$execution$2f$values$2e$mjs__$28$ecmascript$29$__["getVariableValues"],
    "responsePathAsArray": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$Path$2e$mjs__$28$ecmascript$29$__["pathToArray"],
    "subscribe": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$execution$2f$subscribe$2e$mjs__$28$ecmascript$29$__["subscribe"]
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$jsutils$2f$Path$2e$mjs__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/graphql/jsutils/Path.mjs (ecmascript, app ssr)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$execution$2f$execute$2e$mjs__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/graphql/execution/execute.mjs (ecmascript, app ssr)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$execution$2f$subscribe$2e$mjs__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/graphql/execution/subscribe.mjs (ecmascript, app ssr)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$graphql$2f$execution$2f$values$2e$mjs__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/graphql/execution/values.mjs (ecmascript, app ssr)");
"__TURBOPACK__ecmascript__hoisting__location__";
;
;
;
;

})()),

};

//# sourceMappingURL=node_modules_graphql_execution_482bea._.js.map