(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["static/chunks/app/node_modules_@apollo_experimental-nextjs-app-support_dist_57bf66._.js", {

"[project]/node_modules/@apollo/experimental-nextjs-app-support/dist/rsc/registerApolloClient.js (ecmascript, app)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.registerApolloClient = void 0;
__turbopack_require__("[project]/node_modules/next/dist/compiled/server-only/index.js (ecmascript, app)");
const React = __importStar(__turbopack_require__("[project]/node_modules/next/dist/compiled/react/index.js (ecmascript, app)"));
function registerApolloClient(makeClient) {
    const getClient = React.cache(makeClient);
    return {
        getClient
    };
}
exports.registerApolloClient = registerApolloClient; //# sourceMappingURL=registerApolloClient.js.map

}.call(this) }),
"[project]/node_modules/@apollo/experimental-nextjs-app-support/dist/rsc/index.js (ecmascript, app)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.registerApolloClient = void 0;
var registerApolloClient_1 = __turbopack_require__("[project]/node_modules/@apollo/experimental-nextjs-app-support/dist/rsc/registerApolloClient.js (ecmascript, app)");
Object.defineProperty(exports, "registerApolloClient", {
    enumerable: true,
    get: function() {
        return registerApolloClient_1.registerApolloClient;
    }
}); //# sourceMappingURL=index.js.map

}.call(this) }),
"[project]/node_modules/@apollo/experimental-nextjs-app-support/dist/ssr/ApolloRehydrateSymbols.js (ecmascript, app)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ApolloBackgroundQueryTransport = exports.ApolloSSRDataTransport = exports.ApolloResultCache = exports.ApolloRehydrationCache = void 0;
exports.ApolloRehydrationCache = Symbol.for("ApolloRehydrationCache");
exports.ApolloResultCache = Symbol.for("ApolloResultCache");
exports.ApolloSSRDataTransport = Symbol.for("ApolloSSRDataTransport");
exports.ApolloBackgroundQueryTransport = Symbol.for("ApolloBackgroundQueryTransport"); //# sourceMappingURL=ApolloRehydrateSymbols.js.map

}.call(this) }),
"[project]/node_modules/@apollo/experimental-nextjs-app-support/dist/ssr/lateInitializingQueue.js (ecmascript, app)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.registerLateInitializingQueue = void 0;
/**
 * Registers a queue that can be filled with data before it has actually been initialized with this function.
 * Before calling this function, `window[key]` can just be handled as an array of data.
 * When calling this funcation, all accumulated data will be passed to the callback.
 * After calling this function, `window[key]` will be an object with a `push` method that will call the callback with the data.
 */ function registerLateInitializingQueue(key, callback) {
    if (typeof window !== "undefined") {
        const previousData = window[key] || [];
        if (Array.isArray(previousData)) {
            window[key] = {
                push: function() {
                    for(var _len = arguments.length, data = new Array(_len), _key = 0; _key < _len; _key++){
                        data[_key] = arguments[_key];
                    }
                    for (const value of data){
                        callback(value);
                    }
                }
            };
            window[key].push(...previousData);
        }
    }
}
exports.registerLateInitializingQueue = registerLateInitializingQueue; //# sourceMappingURL=lateInitializingQueue.js.map

}.call(this) }),
"[project]/node_modules/@apollo/experimental-nextjs-app-support/dist/ssr/NextSSRApolloClient.js (ecmascript, app)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.NextSSRApolloClient = void 0;
const client_1 = __turbopack_require__("[project]/node_modules/@apollo/client/index.js (ecmascript, app)");
const graphql_1 = __turbopack_require__("[project]/node_modules/graphql/index.mjs (ecmascript, app)");
const cache_1 = __turbopack_require__("[project]/node_modules/@apollo/client/cache/index.js (ecmascript, app)");
const lateInitializingQueue_1 = __turbopack_require__("[project]/node_modules/@apollo/experimental-nextjs-app-support/dist/ssr/lateInitializingQueue.js (ecmascript, app)");
const ApolloRehydrateSymbols_1 = __turbopack_require__("[project]/node_modules/@apollo/experimental-nextjs-app-support/dist/ssr/ApolloRehydrateSymbols.js (ecmascript, app)");
const ts_invariant_1 = __importDefault(__turbopack_require__("[project]/node_modules/ts-invariant/lib/invariant.js (ecmascript, app)"));
function getQueryManager(client) {
    return client["queryManager"];
}
class NextSSRApolloClient extends client_1.ApolloClient {
    constructor(options){
        super(options);
        this.rehydrationContext = {
            incomingBackgroundQueries: []
        };
        this.simulatedStreamingQueries = new Map();
        this.registerWindowHook();
    }
    identifyUniqueQuery(options) {
        const transformedDocument = this.documentTransform.transformDocument(options.query);
        const queryManager = getQueryManager(this);
        // Calling `transformDocument` will add __typename but won't remove client
        // directives, so we need to get the `serverQuery`.
        const { serverQuery } = queryManager.getDocumentInfo(transformedDocument);
        if (!serverQuery) {
            throw new Error("could not identify unique query");
        }
        const canonicalVariables = (0, cache_1.canonicalStringify)(options.variables || {});
        const cacheKey = [
            (0, graphql_1.print)(serverQuery),
            canonicalVariables
        ].toString();
        return {
            query: serverQuery,
            cacheKey,
            varJson: canonicalVariables
        };
    }
    registerWindowHook() {
        if (typeof window !== "undefined") {
            if (Array.isArray(window[ApolloRehydrateSymbols_1.ApolloBackgroundQueryTransport] || [])) {
                (0, lateInitializingQueue_1.registerLateInitializingQueue)(ApolloRehydrateSymbols_1.ApolloBackgroundQueryTransport, (options)=>{
                    // we are not streaming anymore, so we should not simulate "server-side requests"
                    if (document.readyState === "complete") return;
                    const { query, varJson, cacheKey } = this.identifyUniqueQuery(options);
                    if (!query) return;
                    const printedServerQuery = (0, graphql_1.print)(query);
                    const queryManager = getQueryManager(this);
                    const byVariables = queryManager["inFlightLinkObservables"].get(printedServerQuery) || new Map();
                    queryManager["inFlightLinkObservables"].set(printedServerQuery, byVariables);
                    if (!byVariables.has(varJson)) {
                        let simulatedStreamingQuery, observable, fetchCancelFn;
                        const cleanup = ()=>{
                            if (queryManager["fetchCancelFns"].get(cacheKey) === fetchCancelFn) queryManager["fetchCancelFns"].delete(cacheKey);
                            if (byVariables.get(varJson) === observable) byVariables.delete(varJson);
                            if (this.simulatedStreamingQueries.get(cacheKey) === simulatedStreamingQuery) this.simulatedStreamingQueries.delete(cacheKey);
                        };
                        const promise = new Promise((resolve, reject)=>{
                            this.simulatedStreamingQueries.set(cacheKey, simulatedStreamingQuery = {
                                resolve,
                                reject,
                                options
                            });
                        });
                        promise.finally(cleanup);
                        byVariables.set(varJson, observable = new client_1.Observable((observer)=>{
                            promise.then((result)=>{
                                observer.next(result);
                                observer.complete();
                            }).catch((err)=>{
                                observer.error(err);
                            });
                        }));
                        queryManager["fetchCancelFns"].set(cacheKey, fetchCancelFn = (reason)=>{
                            var _a;
                            const { reject } = (_a = this.simulatedStreamingQueries.get(cacheKey)) !== null && _a !== void 0 ? _a : {};
                            if (reject) {
                                reject(reason);
                            }
                            cleanup();
                        });
                    }
                });
                if (document.readyState !== "complete") {
                    const rerunSimulatedQueries = ()=>{
                        const queryManager = getQueryManager(this);
                        // streaming finished, so we need to refire all "server-side requests"
                        // that are still not resolved on the browser side to make sure we have all the data
                        for (const [cacheKey, queryInfo] of this.simulatedStreamingQueries){
                            this.simulatedStreamingQueries.delete(cacheKey);
                            ts_invariant_1.default.debug("streaming connection closed before server query could be fully transported, rerunning:", queryInfo.options);
                            const queryId = queryManager.generateQueryId();
                            queryManager.fetchQuery(queryId, Object.assign(Object.assign({}, queryInfo.options), {
                                context: Object.assign(Object.assign({}, queryInfo.options.context), {
                                    queryDeduplication: false
                                })
                            })).finally(()=>queryManager.stopQuery(queryId)).then(queryInfo.resolve, queryInfo.reject);
                        }
                    };
                    // happens simulatenously to `readyState` changing to `"complete"`, see
                    // https://html.spec.whatwg.org/multipage/parsing.html#the-end (step 9.1 and 9.5)
                    window.addEventListener("load", rerunSimulatedQueries, {
                        once: true
                    });
                }
            }
            if (Array.isArray(window[ApolloRehydrateSymbols_1.ApolloResultCache] || [])) {
                (0, lateInitializingQueue_1.registerLateInitializingQueue)(ApolloRehydrateSymbols_1.ApolloResultCache, (data)=>{
                    var _a;
                    const { cacheKey } = this.identifyUniqueQuery(data);
                    const { resolve } = (_a = this.simulatedStreamingQueries.get(cacheKey)) !== null && _a !== void 0 ? _a : {};
                    if (resolve) {
                        resolve({
                            data: data.result
                        });
                    }
                    // In order to avoid a scenario where the promise resolves without
                    // a query subscribing to the promise, we immediately call
                    // `cache.write` here.
                    // For more information, see: https://github.com/apollographql/apollo-client-nextjs/pull/38/files/388813a16e2ac5c62408923a1face9ae9417d92a#r1229870523
                    this.cache.write(data);
                });
            }
        }
    }
    watchQuery(options) {
        if (typeof window == "undefined") {
            if (options.fetchPolicy !== "cache-only" && options.fetchPolicy !== "standby") {
                this.rehydrationContext.incomingBackgroundQueries.push(options);
            }
        }
        const result = super.watchQuery(options);
        return result;
    }
    setRehydrationContext(rehydrationContext) {
        if (rehydrationContext.incomingBackgroundQueries !== this.rehydrationContext.incomingBackgroundQueries) rehydrationContext.incomingBackgroundQueries.push(...this.rehydrationContext.incomingBackgroundQueries.splice(0));
        this.rehydrationContext = rehydrationContext;
    }
}
exports.NextSSRApolloClient = NextSSRApolloClient; //# sourceMappingURL=NextSSRApolloClient.js.map

}.call(this) }),
"[project]/node_modules/@apollo/experimental-nextjs-app-support/dist/ssr/dataTransport.js (ecmascript, app)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.registerDataTransport = exports.transportDataToJS = void 0;
const superjson_1 = __importDefault(__turbopack_require__("[project]/node_modules/superjson/dist/esm/index.js (ecmascript, app)"));
const ApolloRehydrateSymbols_1 = __turbopack_require__("[project]/node_modules/@apollo/experimental-nextjs-app-support/dist/ssr/ApolloRehydrateSymbols.js (ecmascript, app)");
const lateInitializingQueue_1 = __turbopack_require__("[project]/node_modules/@apollo/experimental-nextjs-app-support/dist/ssr/lateInitializingQueue.js (ecmascript, app)");
const ts_invariant_1 = __importDefault(__turbopack_require__("[project]/node_modules/ts-invariant/lib/invariant.js (ecmascript, app)"));
/**
 * Returns a string of JavaScript that can be used to transport data to the client.
 */ function transportDataToJS(data) {
    const key = Symbol.keyFor(ApolloRehydrateSymbols_1.ApolloSSRDataTransport);
    return `(window[Symbol.for("${key}")] ??= []).push(${superjson_1.default.stringify(data)})`;
}
exports.transportDataToJS = transportDataToJS;
/**
 * Registers a lazy queue that will be filled with data by `transportDataToJS`.
 * All incoming data will be added either to the rehydration cache or the result cache.
 */ function registerDataTransport() {
    (0, lateInitializingQueue_1.registerLateInitializingQueue)(ApolloRehydrateSymbols_1.ApolloSSRDataTransport, (data)=>{
        var _a, _b, _c;
        const parsed = superjson_1.default.deserialize(data);
        ts_invariant_1.default.debug(`received data from the server:`, parsed);
        Object.assign((_a = window[ApolloRehydrateSymbols_1.ApolloRehydrationCache]) !== null && _a !== void 0 ? _a : window[ApolloRehydrateSymbols_1.ApolloRehydrationCache] = {}, parsed.rehydrate);
        ((_b = window[ApolloRehydrateSymbols_1.ApolloBackgroundQueryTransport]) !== null && _b !== void 0 ? _b : window[ApolloRehydrateSymbols_1.ApolloBackgroundQueryTransport] = []).push(...parsed.backgroundQueries);
        ((_c = window[ApolloRehydrateSymbols_1.ApolloResultCache]) !== null && _c !== void 0 ? _c : window[ApolloRehydrateSymbols_1.ApolloResultCache] = []).push(...parsed.results);
    });
}
exports.registerDataTransport = registerDataTransport; //# sourceMappingURL=dataTransport.js.map

}.call(this) }),
"[project]/node_modules/@apollo/experimental-nextjs-app-support/dist/ssr/NextSSRInMemoryCache.js (ecmascript, app)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.NextSSRInMemoryCache = void 0;
const client_1 = __turbopack_require__("[project]/node_modules/@apollo/client/index.js (ecmascript, app)");
class NextSSRInMemoryCache extends client_1.InMemoryCache {
    constructor(config){
        super(config);
        this.rehydrationContext = {
            incomingResults: [],
            uninitialized: true
        };
    }
    write(options) {
        if (typeof window == "undefined") {
            this.rehydrationContext.incomingResults.push(options);
        }
        return super.write(options);
    }
    setRehydrationContext(rehydrationContext) {
        if (this.rehydrationContext.uninitialized) {
            rehydrationContext.incomingResults.push(...this.rehydrationContext.incomingResults);
        }
        this.rehydrationContext = rehydrationContext;
        this.rehydrationContext.uninitialized = false;
    }
}
exports.NextSSRInMemoryCache = NextSSRInMemoryCache; //# sourceMappingURL=NextSSRInMemoryCache.js.map

}.call(this) }),
"[project]/node_modules/@apollo/experimental-nextjs-app-support/dist/ssr/RehydrationContext.js (ecmascript, app)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.useRehydrationContext = exports.RehydrationContextProvider = void 0;
const client_1 = __turbopack_require__("[project]/node_modules/@apollo/client/index.js (ecmascript, app)");
const react_1 = __importDefault(__turbopack_require__("[project]/node_modules/next/dist/compiled/react/index.js (ecmascript, app)"));
const NextSSRInMemoryCache_1 = __turbopack_require__("[project]/node_modules/@apollo/experimental-nextjs-app-support/dist/ssr/NextSSRInMemoryCache.js (ecmascript, app)");
const navigation_1 = __turbopack_require__("[project]/node_modules/next/navigation.js (ecmascript, app)");
const dataTransport_1 = __turbopack_require__("[project]/node_modules/@apollo/experimental-nextjs-app-support/dist/ssr/dataTransport.js (ecmascript, app)");
const ts_invariant_1 = __importDefault(__turbopack_require__("[project]/node_modules/ts-invariant/lib/invariant.js (ecmascript, app)"));
const NextSSRApolloClient_1 = __turbopack_require__("[project]/node_modules/@apollo/experimental-nextjs-app-support/dist/ssr/NextSSRApolloClient.js (ecmascript, app)");
const ApolloRehydrationContext = react_1.default.createContext(undefined);
const RehydrationContextProvider = (param)=>{
    let { children } = param;
    const client = (0, client_1.useApolloClient)();
    const rehydrationContext = react_1.default.useRef();
    if (typeof window == "undefined") {
        if (!rehydrationContext.current) {
            rehydrationContext.current = buildApolloRehydrationContext();
        }
        if (client instanceof NextSSRApolloClient_1.NextSSRApolloClient) {
            client.setRehydrationContext(rehydrationContext.current);
        } else {
            throw new Error("When using Next SSR, you must use the `NextSSRApolloClient`");
        }
        if (client.cache instanceof NextSSRInMemoryCache_1.NextSSRInMemoryCache) {
            client.cache.setRehydrationContext(rehydrationContext.current);
        } else {
            throw new Error("When using Next SSR, you must use the `NextSSRInMemoryCache`");
        }
    } else {
        (0, dataTransport_1.registerDataTransport)();
    }
    return react_1.default.createElement(ApolloRehydrationContext.Provider, {
        value: rehydrationContext.current
    }, children);
};
exports.RehydrationContextProvider = RehydrationContextProvider;
function useRehydrationContext() {
    const rehydrationContext = react_1.default.useContext(ApolloRehydrationContext);
    const insertHtml = react_1.default.useContext(navigation_1.ServerInsertedHTMLContext);
    // help transpilers to omit this code in bundling
    if (typeof window !== "undefined") return;
    if (insertHtml && rehydrationContext && !rehydrationContext.currentlyInjected) {
        rehydrationContext.currentlyInjected = true;
        insertHtml(()=>react_1.default.createElement(rehydrationContext.RehydrateOnClient, null));
    }
    return rehydrationContext;
}
exports.useRehydrationContext = useRehydrationContext;
function buildApolloRehydrationContext() {
    const rehydrationContext = {
        currentlyInjected: false,
        transportValueData: {},
        transportedValues: {},
        incomingResults: [],
        incomingBackgroundQueries: [],
        RehydrateOnClient () {
            rehydrationContext.currentlyInjected = false;
            if (!Object.keys(rehydrationContext.transportValueData).length && !Object.keys(rehydrationContext.incomingResults).length && !Object.keys(rehydrationContext.incomingBackgroundQueries).length) return react_1.default.createElement(react_1.default.Fragment, null);
            ts_invariant_1.default.debug("transporting data", rehydrationContext.transportValueData);
            ts_invariant_1.default.debug("transporting results", rehydrationContext.incomingResults);
            ts_invariant_1.default.debug("transporting incomingBackgroundQueries", rehydrationContext.incomingBackgroundQueries);
            const __html = (0, dataTransport_1.transportDataToJS)({
                rehydrate: Object.fromEntries(Object.entries(rehydrationContext.transportValueData).filter((param)=>{
                    let [key, value] = param;
                    return rehydrationContext.transportedValues[key] !== value;
                })),
                results: rehydrationContext.incomingResults,
                backgroundQueries: rehydrationContext.incomingBackgroundQueries
            });
            Object.assign(rehydrationContext.transportedValues, rehydrationContext.transportValueData);
            rehydrationContext.transportValueData = {};
            rehydrationContext.incomingResults = [];
            rehydrationContext.incomingBackgroundQueries = [];
            return react_1.default.createElement("script", {
                dangerouslySetInnerHTML: {
                    __html
                }
            });
        }
    };
    return rehydrationContext;
} //# sourceMappingURL=RehydrationContext.js.map

}.call(this) }),
"[project]/node_modules/@apollo/experimental-nextjs-app-support/dist/ssr/ApolloNextAppProvider.js (ecmascript, app)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

"use strict";
"use client";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ApolloNextAppProvider = exports.ApolloClientSingleton = void 0;
const React = __importStar(__turbopack_require__("[project]/node_modules/next/dist/compiled/react/index.js (ecmascript, app)"));
const client_1 = __turbopack_require__("[project]/node_modules/@apollo/client/index.js (ecmascript, app)");
const RehydrationContext_1 = __turbopack_require__("[project]/node_modules/@apollo/experimental-nextjs-app-support/dist/ssr/RehydrationContext.js (ecmascript, app)");
exports.ApolloClientSingleton = Symbol.for("ApolloClientSingleton");
const ApolloNextAppProvider = (param)=>{
    let { makeClient, children } = param;
    var _a;
    const clientRef = React.useRef();
    if (typeof window !== "undefined") {
        clientRef.current = (_a = window[exports.ApolloClientSingleton]) !== null && _a !== void 0 ? _a : window[exports.ApolloClientSingleton] = makeClient();
    } else {
        if (!clientRef.current) {
            clientRef.current = makeClient();
        }
    }
    return React.createElement(client_1.ApolloProvider, {
        client: clientRef.current
    }, React.createElement(RehydrationContext_1.RehydrationContextProvider, null, children));
};
exports.ApolloNextAppProvider = ApolloNextAppProvider; //# sourceMappingURL=ApolloNextAppProvider.js.map

}.call(this) }),
"[project]/node_modules/@apollo/experimental-nextjs-app-support/dist/ssr/testHelpers.js (ecmascript, app)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.resetNextSSRApolloSingletons = void 0;
const ApolloNextAppProvider_1 = __turbopack_require__("[project]/node_modules/@apollo/experimental-nextjs-app-support/dist/ssr/ApolloNextAppProvider.js (ecmascript, app)");
const ApolloRehydrateSymbols_1 = __turbopack_require__("[project]/node_modules/@apollo/experimental-nextjs-app-support/dist/ssr/ApolloRehydrateSymbols.js (ecmascript, app)");
/**
 * Resets the singleton instances created for the Apollo SSR data transport and caches.
 *
 * To be used in testing only, like
 * ```ts
 * afterEach(resetNextSSRApolloSingletons);
 * ```
 */ function resetNextSSRApolloSingletons() {
    delete window[ApolloRehydrateSymbols_1.ApolloRehydrationCache];
    delete window[ApolloRehydrateSymbols_1.ApolloResultCache];
    delete window[ApolloRehydrateSymbols_1.ApolloSSRDataTransport];
    delete window[ApolloRehydrateSymbols_1.ApolloBackgroundQueryTransport];
    delete window[ApolloNextAppProvider_1.ApolloClientSingleton];
}
exports.resetNextSSRApolloSingletons = resetNextSSRApolloSingletons; //# sourceMappingURL=testHelpers.js.map

}.call(this) }),
"[project]/node_modules/@apollo/experimental-nextjs-app-support/dist/ssr/RemoveMultipartDirectivesLink.js (ecmascript, app)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RemoveMultipartDirectivesLink = void 0;
const client_1 = __turbopack_require__("[project]/node_modules/@apollo/client/index.js (ecmascript, app)");
const utilities_1 = __turbopack_require__("[project]/node_modules/@apollo/client/utilities/index.js (ecmascript, app)");
function getDirectiveArgumentValue(directive, argument) {
    var _a, _b;
    return (_b = (_a = directive.arguments) === null || _a === void 0 ? void 0 : _a.find((arg)=>arg.name.value === argument)) === null || _b === void 0 ? void 0 : _b.value;
}
/**
 * This link is used to strip directives from the query before it is sent to the server.
 * This is used to prevent the server from doing additional work in SSR scenarios where multipart responses cannot be handled anyways.
 * This stripping behaviour can be configured per-directive.
 * It be overridden by adding a label to the directive.
 * In the case this link is configured to strip a directive, but the directive has a label starting with "SsrDontStrip", the directive will not be stripped.
 * In the case this link is configured to not strip a directive, but the directive has a label starting with "SsrStrip", the directive will be stripped.
 * The "starting with" is important, because labels have to be unique per operation. So if you have multiple directives where you want to override the default stipping behaviour,
 * you can do this by annotating them like
 * ```gql
 * query myQuery {
 *   fastField
 *   ... @defer(label: "SsrDontStrip1") {
 *     slowField1
 *   }
 *   ... @defer(label: "SsrDontStrip2") {
 *     slowField2
 *   }
 * }
 * ```
 *
 */ class RemoveMultipartDirectivesLink extends client_1.ApolloLink {
    constructor(config){
        super();
        this.stripDirectives = [];
        if (config.stripDefer !== false) this.stripDirectives.push("defer");
    }
    request(operation, forward) {
        if (!forward) {
            throw new Error("This is not a terminal link!");
        }
        const { query } = operation;
        let modifiedQuery = query;
        modifiedQuery = (0, utilities_1.removeDirectivesFromDocument)(this.stripDirectives.map((directive)=>({
                test (node) {
                    let shouldStrip = node.kind === "Directive" && node.name.value === directive;
                    const label = getDirectiveArgumentValue(node, "label");
                    if ((label === null || label === void 0 ? void 0 : label.kind) === "StringValue" && label.value.startsWith("SsrDontStrip")) {
                        shouldStrip = false;
                    }
                    return shouldStrip;
                },
                remove: true
            })).concat({
            test (node) {
                if (node.kind !== "Directive") return false;
                const label = getDirectiveArgumentValue(node, "label");
                return (label === null || label === void 0 ? void 0 : label.kind) === "StringValue" && label.value.startsWith("SsrStrip");
            },
            remove: true
        }), modifiedQuery);
        if (modifiedQuery === null) {
            return utilities_1.Observable.of({});
        }
        operation.query = modifiedQuery;
        return forward(operation);
    }
}
exports.RemoveMultipartDirectivesLink = RemoveMultipartDirectivesLink; //# sourceMappingURL=RemoveMultipartDirectivesLink.js.map

}.call(this) }),
"[project]/node_modules/@apollo/experimental-nextjs-app-support/dist/ssr/AccumulateMultipartResponsesLink.js (ecmascript, app)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AccumulateMultipartResponsesLink = void 0;
const client_1 = __turbopack_require__("[project]/node_modules/@apollo/client/index.js (ecmascript, app)");
const utilities_1 = __turbopack_require__("[project]/node_modules/@apollo/client/utilities/index.js (ecmascript, app)");
class AccumulateMultipartResponsesLink extends client_1.ApolloLink {
    constructor(config){
        super();
        this.maxDelay = config.cutoffDelay;
    }
    request(operation, forward) {
        if (!forward) {
            throw new Error("This is not a terminal link!");
        }
        const operationContainsMultipartDirectives = (0, utilities_1.hasDirectives)([
            "defer"
        ], operation.query);
        const upstream = forward(operation);
        if (!operationContainsMultipartDirectives) return upstream;
        // TODO: this could be overwritten with a `@AccumulateMultipartResponsesConfig(maxDelay: 1000)` directive on the operation
        const maxDelay = this.maxDelay;
        let accumulatedData, maxDelayTimeout;
        return new utilities_1.Observable((subscriber)=>{
            const upstreamSubscription = upstream.subscribe({
                next: (result)=>{
                    if (accumulatedData) {
                        if (accumulatedData.data && "incremental" in result) {
                            accumulatedData.data = (0, utilities_1.mergeIncrementalData)(accumulatedData.data, result);
                        } else if (result.data) {
                            accumulatedData.data = result.data;
                        }
                        if (result.errors) {
                            accumulatedData.errors = [
                                ...accumulatedData.errors || [],
                                ...result.errors || []
                            ];
                        }
                        // the spec is not mentioning on how to merge these, so we just do a shallow merge?
                        if (result.extensions) accumulatedData.extensions = Object.assign(Object.assign({}, accumulatedData.extensions), result.extensions);
                    } else {
                        accumulatedData = result;
                    }
                    if (!maxDelay) {
                        flushAccumulatedData();
                    } else if (!maxDelayTimeout) {
                        maxDelayTimeout = setTimeout(flushAccumulatedData, maxDelay);
                    }
                },
                error: (error)=>{
                    if (maxDelayTimeout) clearTimeout(maxDelayTimeout);
                    subscriber.error(error);
                },
                complete: ()=>{
                    if (maxDelayTimeout) {
                        clearTimeout(maxDelayTimeout);
                        flushAccumulatedData();
                    }
                    subscriber.complete();
                }
            });
            function flushAccumulatedData() {
                subscriber.next(accumulatedData);
                subscriber.complete();
                upstreamSubscription.unsubscribe();
            }
            return function cleanUp() {
                clearTimeout(maxDelayTimeout);
                upstreamSubscription.unsubscribe();
            };
        });
    }
}
exports.AccumulateMultipartResponsesLink = AccumulateMultipartResponsesLink; //# sourceMappingURL=AccumulateMultipartResponsesLink.js.map

}.call(this) }),
"[project]/node_modules/@apollo/experimental-nextjs-app-support/dist/ssr/SSRMultipartLink.js (ecmascript, app)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SSRMultipartLink = void 0;
const client_1 = __turbopack_require__("[project]/node_modules/@apollo/client/index.js (ecmascript, app)");
const RemoveMultipartDirectivesLink_1 = __turbopack_require__("[project]/node_modules/@apollo/experimental-nextjs-app-support/dist/ssr/RemoveMultipartDirectivesLink.js (ecmascript, app)");
const AccumulateMultipartResponsesLink_1 = __turbopack_require__("[project]/node_modules/@apollo/experimental-nextjs-app-support/dist/ssr/AccumulateMultipartResponsesLink.js (ecmascript, app)");
class SSRMultipartLink extends client_1.ApolloLink {
    constructor(config = {}){
        const combined = client_1.ApolloLink.from([
            new RemoveMultipartDirectivesLink_1.RemoveMultipartDirectivesLink({
                stripDefer: config.stripDefer
            }),
            new AccumulateMultipartResponsesLink_1.AccumulateMultipartResponsesLink({
                cutoffDelay: config.cutoffDelay || 0
            })
        ]);
        super(combined.request);
    }
}
exports.SSRMultipartLink = SSRMultipartLink; //# sourceMappingURL=SSRMultipartLink.js.map

}.call(this) }),
"[project]/node_modules/@apollo/experimental-nextjs-app-support/dist/ssr/useTransportValue.js (ecmascript, app)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

"use strict";
"use client";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.useTransportValue = void 0;
const react_1 = __turbopack_require__("[project]/node_modules/next/dist/compiled/react/index.js (ecmascript, app)");
const ApolloRehydrateSymbols_1 = __turbopack_require__("[project]/node_modules/@apollo/experimental-nextjs-app-support/dist/ssr/ApolloRehydrateSymbols.js (ecmascript, app)");
const RehydrationContext_1 = __turbopack_require__("[project]/node_modules/@apollo/experimental-nextjs-app-support/dist/ssr/RehydrationContext.js (ecmascript, app)");
/**
 * A hook that mostly acts as an identity function.
 * It will only behave differently during
 * the first render on the client, in which case it will
 * try to return the last value it was called with by
 * the same component during SSR. If that is successful,
 * it will schedule another rerender, to after hydration
 * the component can change to client-side values instead.
 */ function useTransportValue(value) {
    const id = (0, react_1.useId)();
    const [isClient, setIsClient] = (0, react_1.useState)(false);
    (0, react_1.useEffect)(()=>setIsClient(true), []);
    const rehydrationContext = (0, RehydrationContext_1.useRehydrationContext)();
    if (typeof window == "undefined") {
        if (rehydrationContext) {
            rehydrationContext.transportValueData[id] = value;
        }
    } else {
        const store = window[ApolloRehydrateSymbols_1.ApolloRehydrationCache];
        if (store) {
            if (isClient) {
                delete store[id];
            }
            if (id in store) value = store[id];
        }
    }
    return value;
}
exports.useTransportValue = useTransportValue; //# sourceMappingURL=useTransportValue.js.map

}.call(this) }),
"[project]/node_modules/@apollo/experimental-nextjs-app-support/dist/ssr/hooks.js (ecmascript, app)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

"use strict";
"use client";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.useBackgroundQuery = exports.useReadQuery = exports.useSuspenseQuery = exports.useQuery = exports.useFragment = void 0;
const client_1 = __turbopack_require__("[project]/node_modules/@apollo/client/index.js (ecmascript, app)");
const useTransportValue_1 = __turbopack_require__("[project]/node_modules/@apollo/experimental-nextjs-app-support/dist/ssr/useTransportValue.js (ecmascript, app)");
const RehydrationContext_1 = __turbopack_require__("[project]/node_modules/@apollo/experimental-nextjs-app-support/dist/ssr/RehydrationContext.js (ecmascript, app)");
exports.useFragment = wrap(client_1.useFragment, [
    "data",
    "complete",
    "missing"
]);
exports.useQuery = wrap(typeof window === "undefined" ? (query, options)=>(0, client_1.useQuery)(query, Object.assign(Object.assign({}, options), {
        fetchPolicy: "cache-only"
    })) : client_1.useQuery, [
    "data",
    "loading",
    "networkStatus",
    "called"
]);
exports.useSuspenseQuery = wrap(client_1.useSuspenseQuery, [
    "data",
    "networkStatus"
]);
exports.useReadQuery = wrap(client_1.useReadQuery, [
    "data",
    "networkStatus"
]);
const useBackgroundQuery = function() {
    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
        args[_key] = arguments[_key];
    }
    (0, RehydrationContext_1.useRehydrationContext)();
    return (0, client_1.useBackgroundQuery)(...args);
};
exports.useBackgroundQuery = useBackgroundQuery;
function wrap(useFn, transportKeys) {
    return function() {
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        const result = useFn(...args);
        const transported = {};
        for (const key of transportKeys){
            transported[key] = result[key];
        }
        return Object.assign(Object.assign({}, result), (0, useTransportValue_1.useTransportValue)(transported));
    };
} //# sourceMappingURL=hooks.js.map

}.call(this) }),
"[project]/node_modules/@apollo/experimental-nextjs-app-support/dist/ssr/index.js (ecmascript, app)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, k: __turbopack_refresh__, m: module, e: exports }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.resetNextSSRApolloSingletons = exports.RemoveMultipartDirectivesLink = exports.DebounceMultipartResponsesLink = exports.SSRMultipartLink = exports.useBackgroundQuery = exports.useReadQuery = exports.useSuspenseQuery = exports.useQuery = exports.useFragment = exports.NextSSRApolloClient = exports.NextSSRInMemoryCache = exports.ApolloNextAppProvider = void 0;
var ApolloNextAppProvider_1 = __turbopack_require__("[project]/node_modules/@apollo/experimental-nextjs-app-support/dist/ssr/ApolloNextAppProvider.js (ecmascript, app)");
Object.defineProperty(exports, "ApolloNextAppProvider", {
    enumerable: true,
    get: function() {
        return ApolloNextAppProvider_1.ApolloNextAppProvider;
    }
});
var NextSSRInMemoryCache_1 = __turbopack_require__("[project]/node_modules/@apollo/experimental-nextjs-app-support/dist/ssr/NextSSRInMemoryCache.js (ecmascript, app)");
Object.defineProperty(exports, "NextSSRInMemoryCache", {
    enumerable: true,
    get: function() {
        return NextSSRInMemoryCache_1.NextSSRInMemoryCache;
    }
});
var NextSSRApolloClient_1 = __turbopack_require__("[project]/node_modules/@apollo/experimental-nextjs-app-support/dist/ssr/NextSSRApolloClient.js (ecmascript, app)");
Object.defineProperty(exports, "NextSSRApolloClient", {
    enumerable: true,
    get: function() {
        return NextSSRApolloClient_1.NextSSRApolloClient;
    }
});
var hooks_1 = __turbopack_require__("[project]/node_modules/@apollo/experimental-nextjs-app-support/dist/ssr/hooks.js (ecmascript, app)");
Object.defineProperty(exports, "useFragment", {
    enumerable: true,
    get: function() {
        return hooks_1.useFragment;
    }
});
Object.defineProperty(exports, "useQuery", {
    enumerable: true,
    get: function() {
        return hooks_1.useQuery;
    }
});
Object.defineProperty(exports, "useSuspenseQuery", {
    enumerable: true,
    get: function() {
        return hooks_1.useSuspenseQuery;
    }
});
Object.defineProperty(exports, "useReadQuery", {
    enumerable: true,
    get: function() {
        return hooks_1.useReadQuery;
    }
});
Object.defineProperty(exports, "useBackgroundQuery", {
    enumerable: true,
    get: function() {
        return hooks_1.useBackgroundQuery;
    }
});
var SSRMultipartLink_1 = __turbopack_require__("[project]/node_modules/@apollo/experimental-nextjs-app-support/dist/ssr/SSRMultipartLink.js (ecmascript, app)");
Object.defineProperty(exports, "SSRMultipartLink", {
    enumerable: true,
    get: function() {
        return SSRMultipartLink_1.SSRMultipartLink;
    }
});
var AccumulateMultipartResponsesLink_1 = __turbopack_require__("[project]/node_modules/@apollo/experimental-nextjs-app-support/dist/ssr/AccumulateMultipartResponsesLink.js (ecmascript, app)");
Object.defineProperty(exports, "DebounceMultipartResponsesLink", {
    enumerable: true,
    get: function() {
        return AccumulateMultipartResponsesLink_1.AccumulateMultipartResponsesLink;
    }
});
var RemoveMultipartDirectivesLink_1 = __turbopack_require__("[project]/node_modules/@apollo/experimental-nextjs-app-support/dist/ssr/RemoveMultipartDirectivesLink.js (ecmascript, app)");
Object.defineProperty(exports, "RemoveMultipartDirectivesLink", {
    enumerable: true,
    get: function() {
        return RemoveMultipartDirectivesLink_1.RemoveMultipartDirectivesLink;
    }
});
var testHelpers_1 = __turbopack_require__("[project]/node_modules/@apollo/experimental-nextjs-app-support/dist/ssr/testHelpers.js (ecmascript, app)");
Object.defineProperty(exports, "resetNextSSRApolloSingletons", {
    enumerable: true,
    get: function() {
        return testHelpers_1.resetNextSSRApolloSingletons;
    }
}); //# sourceMappingURL=index.js.map

}.call(this) }),
}]);

//# sourceMappingURL=node_modules_@apollo_experimental-nextjs-app-support_dist_57bf66._.js.map