{
  "version": 3,
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/graphql/execution/values.mjs"],"sourcesContent":["import { inspect } from '../jsutils/inspect.mjs';\nimport { keyMap } from '../jsutils/keyMap.mjs';\nimport { printPathArray } from '../jsutils/printPathArray.mjs';\nimport { GraphQLError } from '../error/GraphQLError.mjs';\nimport { Kind } from '../language/kinds.mjs';\nimport { print } from '../language/printer.mjs';\nimport { isInputType, isNonNullType } from '../type/definition.mjs';\nimport { coerceInputValue } from '../utilities/coerceInputValue.mjs';\nimport { typeFromAST } from '../utilities/typeFromAST.mjs';\nimport { valueFromAST } from '../utilities/valueFromAST.mjs';\n\n/**\n * Prepares an object map of variableValues of the correct type based on the\n * provided variable definitions and arbitrary input. If the input cannot be\n * parsed to match the variable definitions, a GraphQLError will be thrown.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\nexport function getVariableValues(schema, varDefNodes, inputs, options) {\n  const errors = [];\n  const maxErrors =\n    options === null || options === void 0 ? void 0 : options.maxErrors;\n\n  try {\n    const coerced = coerceVariableValues(\n      schema,\n      varDefNodes,\n      inputs,\n      (error) => {\n        if (maxErrors != null && errors.length >= maxErrors) {\n          throw new GraphQLError(\n            'Too many errors processing variables, error limit reached. Execution aborted.',\n          );\n        }\n\n        errors.push(error);\n      },\n    );\n\n    if (errors.length === 0) {\n      return {\n        coerced,\n      };\n    }\n  } catch (error) {\n    errors.push(error);\n  }\n\n  return {\n    errors,\n  };\n}\n\nfunction coerceVariableValues(schema, varDefNodes, inputs, onError) {\n  const coercedValues = {};\n\n  for (const varDefNode of varDefNodes) {\n    const varName = varDefNode.variable.name.value;\n    const varType = typeFromAST(schema, varDefNode.type);\n\n    if (!isInputType(varType)) {\n      // Must use input types for variables. This should be caught during\n      // validation, however is checked again here for safety.\n      const varTypeStr = print(varDefNode.type);\n      onError(\n        new GraphQLError(\n          `Variable \"$${varName}\" expected value of type \"${varTypeStr}\" which cannot be used as an input type.`,\n          {\n            nodes: varDefNode.type,\n          },\n        ),\n      );\n      continue;\n    }\n\n    if (!hasOwnProperty(inputs, varName)) {\n      if (varDefNode.defaultValue) {\n        coercedValues[varName] = valueFromAST(varDefNode.defaultValue, varType);\n      } else if (isNonNullType(varType)) {\n        const varTypeStr = inspect(varType);\n        onError(\n          new GraphQLError(\n            `Variable \"$${varName}\" of required type \"${varTypeStr}\" was not provided.`,\n            {\n              nodes: varDefNode,\n            },\n          ),\n        );\n      }\n\n      continue;\n    }\n\n    const value = inputs[varName];\n\n    if (value === null && isNonNullType(varType)) {\n      const varTypeStr = inspect(varType);\n      onError(\n        new GraphQLError(\n          `Variable \"$${varName}\" of non-null type \"${varTypeStr}\" must not be null.`,\n          {\n            nodes: varDefNode,\n          },\n        ),\n      );\n      continue;\n    }\n\n    coercedValues[varName] = coerceInputValue(\n      value,\n      varType,\n      (path, invalidValue, error) => {\n        let prefix =\n          `Variable \"$${varName}\" got invalid value ` + inspect(invalidValue);\n\n        if (path.length > 0) {\n          prefix += ` at \"${varName}${printPathArray(path)}\"`;\n        }\n\n        onError(\n          new GraphQLError(prefix + '; ' + error.message, {\n            nodes: varDefNode,\n            originalError: error,\n          }),\n        );\n      },\n    );\n  }\n\n  return coercedValues;\n}\n/**\n * Prepares an object map of argument values given a list of argument\n * definitions and list of argument AST nodes.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\n\nexport function getArgumentValues(def, node, variableValues) {\n  var _node$arguments;\n\n  const coercedValues = {}; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n  /* c8 ignore next */\n\n  const argumentNodes =\n    (_node$arguments = node.arguments) !== null && _node$arguments !== void 0\n      ? _node$arguments\n      : [];\n  const argNodeMap = keyMap(argumentNodes, (arg) => arg.name.value);\n\n  for (const argDef of def.args) {\n    const name = argDef.name;\n    const argType = argDef.type;\n    const argumentNode = argNodeMap[name];\n\n    if (!argumentNode) {\n      if (argDef.defaultValue !== undefined) {\n        coercedValues[name] = argDef.defaultValue;\n      } else if (isNonNullType(argType)) {\n        throw new GraphQLError(\n          `Argument \"${name}\" of required type \"${inspect(argType)}\" ` +\n            'was not provided.',\n          {\n            nodes: node,\n          },\n        );\n      }\n\n      continue;\n    }\n\n    const valueNode = argumentNode.value;\n    let isNull = valueNode.kind === Kind.NULL;\n\n    if (valueNode.kind === Kind.VARIABLE) {\n      const variableName = valueNode.name.value;\n\n      if (\n        variableValues == null ||\n        !hasOwnProperty(variableValues, variableName)\n      ) {\n        if (argDef.defaultValue !== undefined) {\n          coercedValues[name] = argDef.defaultValue;\n        } else if (isNonNullType(argType)) {\n          throw new GraphQLError(\n            `Argument \"${name}\" of required type \"${inspect(argType)}\" ` +\n              `was provided the variable \"$${variableName}\" which was not provided a runtime value.`,\n            {\n              nodes: valueNode,\n            },\n          );\n        }\n\n        continue;\n      }\n\n      isNull = variableValues[variableName] == null;\n    }\n\n    if (isNull && isNonNullType(argType)) {\n      throw new GraphQLError(\n        `Argument \"${name}\" of non-null type \"${inspect(argType)}\" ` +\n          'must not be null.',\n        {\n          nodes: valueNode,\n        },\n      );\n    }\n\n    const coercedValue = valueFromAST(valueNode, argType, variableValues);\n\n    if (coercedValue === undefined) {\n      // Note: ValuesOfCorrectTypeRule validation should catch this before\n      // execution. This is a runtime check to ensure execution does not\n      // continue with an invalid argument value.\n      throw new GraphQLError(\n        `Argument \"${name}\" has invalid value ${print(valueNode)}.`,\n        {\n          nodes: valueNode,\n        },\n      );\n    }\n\n    coercedValues[name] = coercedValue;\n  }\n\n  return coercedValues;\n}\n/**\n * Prepares an object map of argument values given a directive definition\n * and a AST node which may contain directives. Optionally also accepts a map\n * of variable values.\n *\n * If the directive does not exist on the node, returns undefined.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\n\nexport function getDirectiveValues(directiveDef, node, variableValues) {\n  var _node$directives;\n\n  const directiveNode =\n    (_node$directives = node.directives) === null || _node$directives === void 0\n      ? void 0\n      : _node$directives.find(\n          (directive) => directive.name.value === directiveDef.name,\n        );\n\n  if (directiveNode) {\n    return getArgumentValues(directiveDef, directiveNode, variableValues);\n  }\n}\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 161, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 165, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/graphql/execution/collectFields.mjs"],"sourcesContent":["import { Kind } from '../language/kinds.mjs';\nimport { isAbstractType } from '../type/definition.mjs';\nimport {\n  GraphQLIncludeDirective,\n  GraphQLSkipDirective,\n} from '../type/directives.mjs';\nimport { typeFromAST } from '../utilities/typeFromAST.mjs';\nimport { getDirectiveValues } from './values.mjs';\n/**\n * Given a selectionSet, collects all of the fields and returns them.\n *\n * CollectFields requires the \"runtime type\" of an object. For a field that\n * returns an Interface or Union type, the \"runtime type\" will be the actual\n * object type returned by that field.\n *\n * @internal\n */\n\nexport function collectFields(\n  schema,\n  fragments,\n  variableValues,\n  runtimeType,\n  selectionSet,\n) {\n  const fields = new Map();\n  collectFieldsImpl(\n    schema,\n    fragments,\n    variableValues,\n    runtimeType,\n    selectionSet,\n    fields,\n    new Set(),\n  );\n  return fields;\n}\n/**\n * Given an array of field nodes, collects all of the subfields of the passed\n * in fields, and returns them at the end.\n *\n * CollectSubFields requires the \"return type\" of an object. For a field that\n * returns an Interface or Union type, the \"return type\" will be the actual\n * object type returned by that field.\n *\n * @internal\n */\n\nexport function collectSubfields(\n  schema,\n  fragments,\n  variableValues,\n  returnType,\n  fieldNodes,\n) {\n  const subFieldNodes = new Map();\n  const visitedFragmentNames = new Set();\n\n  for (const node of fieldNodes) {\n    if (node.selectionSet) {\n      collectFieldsImpl(\n        schema,\n        fragments,\n        variableValues,\n        returnType,\n        node.selectionSet,\n        subFieldNodes,\n        visitedFragmentNames,\n      );\n    }\n  }\n\n  return subFieldNodes;\n}\n\nfunction collectFieldsImpl(\n  schema,\n  fragments,\n  variableValues,\n  runtimeType,\n  selectionSet,\n  fields,\n  visitedFragmentNames,\n) {\n  for (const selection of selectionSet.selections) {\n    switch (selection.kind) {\n      case Kind.FIELD: {\n        if (!shouldIncludeNode(variableValues, selection)) {\n          continue;\n        }\n\n        const name = getFieldEntryKey(selection);\n        const fieldList = fields.get(name);\n\n        if (fieldList !== undefined) {\n          fieldList.push(selection);\n        } else {\n          fields.set(name, [selection]);\n        }\n\n        break;\n      }\n\n      case Kind.INLINE_FRAGMENT: {\n        if (\n          !shouldIncludeNode(variableValues, selection) ||\n          !doesFragmentConditionMatch(schema, selection, runtimeType)\n        ) {\n          continue;\n        }\n\n        collectFieldsImpl(\n          schema,\n          fragments,\n          variableValues,\n          runtimeType,\n          selection.selectionSet,\n          fields,\n          visitedFragmentNames,\n        );\n        break;\n      }\n\n      case Kind.FRAGMENT_SPREAD: {\n        const fragName = selection.name.value;\n\n        if (\n          visitedFragmentNames.has(fragName) ||\n          !shouldIncludeNode(variableValues, selection)\n        ) {\n          continue;\n        }\n\n        visitedFragmentNames.add(fragName);\n        const fragment = fragments[fragName];\n\n        if (\n          !fragment ||\n          !doesFragmentConditionMatch(schema, fragment, runtimeType)\n        ) {\n          continue;\n        }\n\n        collectFieldsImpl(\n          schema,\n          fragments,\n          variableValues,\n          runtimeType,\n          fragment.selectionSet,\n          fields,\n          visitedFragmentNames,\n        );\n        break;\n      }\n    }\n  }\n}\n/**\n * Determines if a field should be included based on the `@include` and `@skip`\n * directives, where `@skip` has higher precedence than `@include`.\n */\n\nfunction shouldIncludeNode(variableValues, node) {\n  const skip = getDirectiveValues(GraphQLSkipDirective, node, variableValues);\n\n  if ((skip === null || skip === void 0 ? void 0 : skip.if) === true) {\n    return false;\n  }\n\n  const include = getDirectiveValues(\n    GraphQLIncludeDirective,\n    node,\n    variableValues,\n  );\n\n  if (\n    (include === null || include === void 0 ? void 0 : include.if) === false\n  ) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * Determines if a fragment is applicable to the given type.\n */\n\nfunction doesFragmentConditionMatch(schema, fragment, type) {\n  const typeConditionNode = fragment.typeCondition;\n\n  if (!typeConditionNode) {\n    return true;\n  }\n\n  const conditionalType = typeFromAST(schema, typeConditionNode);\n\n  if (conditionalType === type) {\n    return true;\n  }\n\n  if (isAbstractType(conditionalType)) {\n    return schema.isSubType(conditionalType, type);\n  }\n\n  return false;\n}\n/**\n * Implements the logic to compute the key of a given field's entry\n */\n\nfunction getFieldEntryKey(node) {\n  return node.alias ? node.alias.value : node.name.value;\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;AAkBO,SAAS,cACd,MAAM,EACN,SAAS,EACT,cAAc,EACd,WAAW,EACX,YAAY;IAEZ,MAAM,SAAS,IAAI;IACnB,kBACE,QACA,WACA,gBACA,aACA,cACA,QACA,IAAI;IAEN,OAAO;AACT;AAYO,SAAS,iBACd,MAAM,EACN,SAAS,EACT,cAAc,EACd,UAAU,EACV,UAAU;IAEV,MAAM,gBAAgB,IAAI;IAC1B,MAAM,uBAAuB,IAAI;IAEjC,KAAK,MAAM,QAAQ,WAAY;QAC7B,IAAI,KAAK,YAAY,EAAE;YACrB,kBACE,QACA,WACA,gBACA,YACA,KAAK,YAAY,EACjB,eACA;QAEJ;IACF;IAEA,OAAO;AACT;AAEA,SAAS,kBACP,MAAM,EACN,SAAS,EACT,cAAc,EACd,WAAW,EACX,YAAY,EACZ,MAAM,EACN,oBAAoB;IAEpB,KAAK,MAAM,aAAa,aAAa,UAAU,CAAE;QAC/C,OAAQ,UAAU,IAAI;YACpB,KAAK,kIAAK,KAAK;gBAAE;oBACf,IAAI,CAAC,kBAAkB,gBAAgB,YAAY;wBACjD;oBACF;oBAEA,MAAM,OAAO,iBAAiB;oBAC9B,MAAM,YAAY,OAAO,GAAG,CAAC;oBAE7B,IAAI,cAAc,WAAW;wBAC3B,UAAU,IAAI,CAAC;oBACjB,OAAO;wBACL,OAAO,GAAG,CAAC,MAAM;4BAAC;yBAAU;oBAC9B;oBAEA;gBACF;YAEA,KAAK,kIAAK,eAAe;gBAAE;oBACzB,IACE,CAAC,kBAAkB,gBAAgB,cACnC,CAAC,2BAA2B,QAAQ,WAAW,cAC/C;wBACA;oBACF;oBAEA,kBACE,QACA,WACA,gBACA,aACA,UAAU,YAAY,EACtB,QACA;oBAEF;gBACF;YAEA,KAAK,kIAAK,eAAe;gBAAE;oBACzB,MAAM,WAAW,UAAU,IAAI,CAAC,KAAK;oBAErC,IACE,qBAAqB,GAAG,CAAC,aACzB,CAAC,kBAAkB,gBAAgB,YACnC;wBACA;oBACF;oBAEA,qBAAqB,GAAG,CAAC;oBACzB,MAAM,WAAW,SAAS,CAAC,SAAS;oBAEpC,IACE,CAAC,YACD,CAAC,2BAA2B,QAAQ,UAAU,cAC9C;wBACA;oBACF;oBAEA,kBACE,QACA,WACA,gBACA,aACA,SAAS,YAAY,EACrB,QACA;oBAEF;gBACF;QACF;IACF;AACF;AACA;;;CAGC,GAED,SAAS,kBAAkB,cAAc,EAAE,IAAI;IAC7C,MAAM,OAAO,sSAAyC,MAAM;IAE5D,IAAI,CAAC,SAAS,QAAQ,SAAS,KAAK,IAAI,KAAK,IAAI,KAAK,EAAE,MAAM,MAAM;QAClE,OAAO;IACT;IAEA,MAAM,UAAU,ySAEd,MACA;IAGF,IACE,CAAC,YAAY,QAAQ,YAAY,KAAK,IAAI,KAAK,IAAI,QAAQ,EAAE,MAAM,OACnE;QACA,OAAO;IACT;IAEA,OAAO;AACT;AACA;;CAEC,GAED,SAAS,2BAA2B,MAAM,EAAE,QAAQ,EAAE,IAAI;IACxD,MAAM,oBAAoB,SAAS,aAAa;IAEhD,IAAI,CAAC,mBAAmB;QACtB,OAAO;IACT;IAEA,MAAM,kBAAkB,gJAAY,QAAQ;IAE5C,IAAI,oBAAoB,MAAM;QAC5B,OAAO;IACT;IAEA,IAAI,6IAAe,kBAAkB;QACnC,OAAO,OAAO,SAAS,CAAC,iBAAiB;IAC3C;IAEA,OAAO;AACT;AACA;;CAEC,GAED,SAAS,iBAAiB,IAAI;IAC5B,OAAO,KAAK,KAAK,GAAG,KAAK,KAAK,CAAC,KAAK,GAAG,KAAK,IAAI,CAAC,KAAK;AACxD"}},
    {"offset": {"line": 274, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 278, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/graphql/execution/execute.mjs"],"sourcesContent":["import { devAssert } from '../jsutils/devAssert.mjs';\nimport { inspect } from '../jsutils/inspect.mjs';\nimport { invariant } from '../jsutils/invariant.mjs';\nimport { isIterableObject } from '../jsutils/isIterableObject.mjs';\nimport { isObjectLike } from '../jsutils/isObjectLike.mjs';\nimport { isPromise } from '../jsutils/isPromise.mjs';\nimport { memoize3 } from '../jsutils/memoize3.mjs';\nimport { addPath, pathToArray } from '../jsutils/Path.mjs';\nimport { promiseForObject } from '../jsutils/promiseForObject.mjs';\nimport { promiseReduce } from '../jsutils/promiseReduce.mjs';\nimport { GraphQLError } from '../error/GraphQLError.mjs';\nimport { locatedError } from '../error/locatedError.mjs';\nimport { OperationTypeNode } from '../language/ast.mjs';\nimport { Kind } from '../language/kinds.mjs';\nimport {\n  isAbstractType,\n  isLeafType,\n  isListType,\n  isNonNullType,\n  isObjectType,\n} from '../type/definition.mjs';\nimport {\n  SchemaMetaFieldDef,\n  TypeMetaFieldDef,\n  TypeNameMetaFieldDef,\n} from '../type/introspection.mjs';\nimport { assertValidSchema } from '../type/validate.mjs';\nimport {\n  collectFields,\n  collectSubfields as _collectSubfields,\n} from './collectFields.mjs';\nimport { getArgumentValues, getVariableValues } from './values.mjs';\n/**\n * A memoized collection of relevant subfields with regard to the return\n * type. Memoizing ensures the subfields are not repeatedly calculated, which\n * saves overhead when resolving lists of values.\n */\n\nconst collectSubfields = memoize3((exeContext, returnType, fieldNodes) =>\n  _collectSubfields(\n    exeContext.schema,\n    exeContext.fragments,\n    exeContext.variableValues,\n    returnType,\n    fieldNodes,\n  ),\n);\n/**\n * Terminology\n *\n * \"Definitions\" are the generic name for top-level statements in the document.\n * Examples of this include:\n * 1) Operations (such as a query)\n * 2) Fragments\n *\n * \"Operations\" are a generic name for requests in the document.\n * Examples of this include:\n * 1) query,\n * 2) mutation\n *\n * \"Selections\" are the definitions that can appear legally and at\n * single level of the query. These include:\n * 1) field references e.g `a`\n * 2) fragment \"spreads\" e.g. `...c`\n * 3) inline fragment \"spreads\" e.g. `...on Type { a }`\n */\n\n/**\n * Data that must be available at all points during query execution.\n *\n * Namely, schema of the type system that is currently executing,\n * and the fragments defined in the query document\n */\n\n/**\n * Implements the \"Executing requests\" section of the GraphQL specification.\n *\n * Returns either a synchronous ExecutionResult (if all encountered resolvers\n * are synchronous), or a Promise of an ExecutionResult that will eventually be\n * resolved and never rejected.\n *\n * If the arguments to this function do not result in a legal execution context,\n * a GraphQLError will be thrown immediately explaining the invalid input.\n */\nexport function execute(args) {\n  // Temporary for v15 to v16 migration. Remove in v17\n  arguments.length < 2 ||\n    devAssert(\n      false,\n      'graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead.',\n    );\n  const { schema, document, variableValues, rootValue } = args; // If arguments are missing or incorrect, throw an error.\n\n  assertValidExecutionArguments(schema, document, variableValues); // If a valid execution context cannot be created due to incorrect arguments,\n  // a \"Response\" with only errors is returned.\n\n  const exeContext = buildExecutionContext(args); // Return early errors if execution context failed.\n\n  if (!('schema' in exeContext)) {\n    return {\n      errors: exeContext,\n    };\n  } // Return a Promise that will eventually resolve to the data described by\n  // The \"Response\" section of the GraphQL specification.\n  //\n  // If errors are encountered while executing a GraphQL field, only that\n  // field and its descendants will be omitted, and sibling fields will still\n  // be executed. An execution which encounters errors will still result in a\n  // resolved Promise.\n  //\n  // Errors from sub-fields of a NonNull type may propagate to the top level,\n  // at which point we still log the error and null the parent field, which\n  // in this case is the entire response.\n\n  try {\n    const { operation } = exeContext;\n    const result = executeOperation(exeContext, operation, rootValue);\n\n    if (isPromise(result)) {\n      return result.then(\n        (data) => buildResponse(data, exeContext.errors),\n        (error) => {\n          exeContext.errors.push(error);\n          return buildResponse(null, exeContext.errors);\n        },\n      );\n    }\n\n    return buildResponse(result, exeContext.errors);\n  } catch (error) {\n    exeContext.errors.push(error);\n    return buildResponse(null, exeContext.errors);\n  }\n}\n/**\n * Also implements the \"Executing requests\" section of the GraphQL specification.\n * However, it guarantees to complete synchronously (or throw an error) assuming\n * that all field resolvers are also synchronous.\n */\n\nexport function executeSync(args) {\n  const result = execute(args); // Assert that the execution was synchronous.\n\n  if (isPromise(result)) {\n    throw new Error('GraphQL execution failed to complete synchronously.');\n  }\n\n  return result;\n}\n/**\n * Given a completed execution context and data, build the `{ errors, data }`\n * response defined by the \"Response\" section of the GraphQL specification.\n */\n\nfunction buildResponse(data, errors) {\n  return errors.length === 0\n    ? {\n        data,\n      }\n    : {\n        errors,\n        data,\n      };\n}\n/**\n * Essential assertions before executing to provide developer feedback for\n * improper use of the GraphQL library.\n *\n * @internal\n */\n\nexport function assertValidExecutionArguments(\n  schema,\n  document,\n  rawVariableValues,\n) {\n  document || devAssert(false, 'Must provide document.'); // If the schema used for execution is invalid, throw an error.\n\n  assertValidSchema(schema); // Variables, if provided, must be an object.\n\n  rawVariableValues == null ||\n    isObjectLike(rawVariableValues) ||\n    devAssert(\n      false,\n      'Variables must be provided as an Object where each property is a variable value. Perhaps look to see if an unparsed JSON string was provided.',\n    );\n}\n/**\n * Constructs a ExecutionContext object from the arguments passed to\n * execute, which we will pass throughout the other execution methods.\n *\n * Throws a GraphQLError if a valid execution context cannot be created.\n *\n * @internal\n */\n\nexport function buildExecutionContext(args) {\n  var _definition$name, _operation$variableDe;\n\n  const {\n    schema,\n    document,\n    rootValue,\n    contextValue,\n    variableValues: rawVariableValues,\n    operationName,\n    fieldResolver,\n    typeResolver,\n    subscribeFieldResolver,\n  } = args;\n  let operation;\n  const fragments = Object.create(null);\n\n  for (const definition of document.definitions) {\n    switch (definition.kind) {\n      case Kind.OPERATION_DEFINITION:\n        if (operationName == null) {\n          if (operation !== undefined) {\n            return [\n              new GraphQLError(\n                'Must provide operation name if query contains multiple operations.',\n              ),\n            ];\n          }\n\n          operation = definition;\n        } else if (\n          ((_definition$name = definition.name) === null ||\n          _definition$name === void 0\n            ? void 0\n            : _definition$name.value) === operationName\n        ) {\n          operation = definition;\n        }\n\n        break;\n\n      case Kind.FRAGMENT_DEFINITION:\n        fragments[definition.name.value] = definition;\n        break;\n\n      default: // ignore non-executable definitions\n    }\n  }\n\n  if (!operation) {\n    if (operationName != null) {\n      return [new GraphQLError(`Unknown operation named \"${operationName}\".`)];\n    }\n\n    return [new GraphQLError('Must provide an operation.')];\n  } // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n  /* c8 ignore next */\n\n  const variableDefinitions =\n    (_operation$variableDe = operation.variableDefinitions) !== null &&\n    _operation$variableDe !== void 0\n      ? _operation$variableDe\n      : [];\n  const coercedVariableValues = getVariableValues(\n    schema,\n    variableDefinitions,\n    rawVariableValues !== null && rawVariableValues !== void 0\n      ? rawVariableValues\n      : {},\n    {\n      maxErrors: 50,\n    },\n  );\n\n  if (coercedVariableValues.errors) {\n    return coercedVariableValues.errors;\n  }\n\n  return {\n    schema,\n    fragments,\n    rootValue,\n    contextValue,\n    operation,\n    variableValues: coercedVariableValues.coerced,\n    fieldResolver:\n      fieldResolver !== null && fieldResolver !== void 0\n        ? fieldResolver\n        : defaultFieldResolver,\n    typeResolver:\n      typeResolver !== null && typeResolver !== void 0\n        ? typeResolver\n        : defaultTypeResolver,\n    subscribeFieldResolver:\n      subscribeFieldResolver !== null && subscribeFieldResolver !== void 0\n        ? subscribeFieldResolver\n        : defaultFieldResolver,\n    errors: [],\n  };\n}\n/**\n * Implements the \"Executing operations\" section of the spec.\n */\n\nfunction executeOperation(exeContext, operation, rootValue) {\n  const rootType = exeContext.schema.getRootType(operation.operation);\n\n  if (rootType == null) {\n    throw new GraphQLError(\n      `Schema is not configured to execute ${operation.operation} operation.`,\n      {\n        nodes: operation,\n      },\n    );\n  }\n\n  const rootFields = collectFields(\n    exeContext.schema,\n    exeContext.fragments,\n    exeContext.variableValues,\n    rootType,\n    operation.selectionSet,\n  );\n  const path = undefined;\n\n  switch (operation.operation) {\n    case OperationTypeNode.QUERY:\n      return executeFields(exeContext, rootType, rootValue, path, rootFields);\n\n    case OperationTypeNode.MUTATION:\n      return executeFieldsSerially(\n        exeContext,\n        rootType,\n        rootValue,\n        path,\n        rootFields,\n      );\n\n    case OperationTypeNode.SUBSCRIPTION:\n      // TODO: deprecate `subscribe` and move all logic here\n      // Temporary solution until we finish merging execute and subscribe together\n      return executeFields(exeContext, rootType, rootValue, path, rootFields);\n  }\n}\n/**\n * Implements the \"Executing selection sets\" section of the spec\n * for fields that must be executed serially.\n */\n\nfunction executeFieldsSerially(\n  exeContext,\n  parentType,\n  sourceValue,\n  path,\n  fields,\n) {\n  return promiseReduce(\n    fields.entries(),\n    (results, [responseName, fieldNodes]) => {\n      const fieldPath = addPath(path, responseName, parentType.name);\n      const result = executeField(\n        exeContext,\n        parentType,\n        sourceValue,\n        fieldNodes,\n        fieldPath,\n      );\n\n      if (result === undefined) {\n        return results;\n      }\n\n      if (isPromise(result)) {\n        return result.then((resolvedResult) => {\n          results[responseName] = resolvedResult;\n          return results;\n        });\n      }\n\n      results[responseName] = result;\n      return results;\n    },\n    Object.create(null),\n  );\n}\n/**\n * Implements the \"Executing selection sets\" section of the spec\n * for fields that may be executed in parallel.\n */\n\nfunction executeFields(exeContext, parentType, sourceValue, path, fields) {\n  const results = Object.create(null);\n  let containsPromise = false;\n\n  try {\n    for (const [responseName, fieldNodes] of fields.entries()) {\n      const fieldPath = addPath(path, responseName, parentType.name);\n      const result = executeField(\n        exeContext,\n        parentType,\n        sourceValue,\n        fieldNodes,\n        fieldPath,\n      );\n\n      if (result !== undefined) {\n        results[responseName] = result;\n\n        if (isPromise(result)) {\n          containsPromise = true;\n        }\n      }\n    }\n  } catch (error) {\n    if (containsPromise) {\n      // Ensure that any promises returned by other fields are handled, as they may also reject.\n      return promiseForObject(results).finally(() => {\n        throw error;\n      });\n    }\n\n    throw error;\n  } // If there are no promises, we can just return the object\n\n  if (!containsPromise) {\n    return results;\n  } // Otherwise, results is a map from field name to the result of resolving that\n  // field, which is possibly a promise. Return a promise that will return this\n  // same map, but with any promises replaced with the values they resolved to.\n\n  return promiseForObject(results);\n}\n/**\n * Implements the \"Executing fields\" section of the spec\n * In particular, this function figures out the value that the field returns by\n * calling its resolve function, then calls completeValue to complete promises,\n * serialize scalars, or execute the sub-selection-set for objects.\n */\n\nfunction executeField(exeContext, parentType, source, fieldNodes, path) {\n  var _fieldDef$resolve;\n\n  const fieldDef = getFieldDef(exeContext.schema, parentType, fieldNodes[0]);\n\n  if (!fieldDef) {\n    return;\n  }\n\n  const returnType = fieldDef.type;\n  const resolveFn =\n    (_fieldDef$resolve = fieldDef.resolve) !== null &&\n    _fieldDef$resolve !== void 0\n      ? _fieldDef$resolve\n      : exeContext.fieldResolver;\n  const info = buildResolveInfo(\n    exeContext,\n    fieldDef,\n    fieldNodes,\n    parentType,\n    path,\n  ); // Get the resolve function, regardless of if its result is normal or abrupt (error).\n\n  try {\n    // Build a JS object of arguments from the field.arguments AST, using the\n    // variables scope to fulfill any variable references.\n    // TODO: find a way to memoize, in case this field is within a List type.\n    const args = getArgumentValues(\n      fieldDef,\n      fieldNodes[0],\n      exeContext.variableValues,\n    ); // The resolve function's optional third argument is a context value that\n    // is provided to every resolve function within an execution. It is commonly\n    // used to represent an authenticated user, or request-specific caches.\n\n    const contextValue = exeContext.contextValue;\n    const result = resolveFn(source, args, contextValue, info);\n    let completed;\n\n    if (isPromise(result)) {\n      completed = result.then((resolved) =>\n        completeValue(exeContext, returnType, fieldNodes, info, path, resolved),\n      );\n    } else {\n      completed = completeValue(\n        exeContext,\n        returnType,\n        fieldNodes,\n        info,\n        path,\n        result,\n      );\n    }\n\n    if (isPromise(completed)) {\n      // Note: we don't rely on a `catch` method, but we do expect \"thenable\"\n      // to take a second callback for the error case.\n      return completed.then(undefined, (rawError) => {\n        const error = locatedError(rawError, fieldNodes, pathToArray(path));\n        return handleFieldError(error, returnType, exeContext);\n      });\n    }\n\n    return completed;\n  } catch (rawError) {\n    const error = locatedError(rawError, fieldNodes, pathToArray(path));\n    return handleFieldError(error, returnType, exeContext);\n  }\n}\n/**\n * @internal\n */\n\nexport function buildResolveInfo(\n  exeContext,\n  fieldDef,\n  fieldNodes,\n  parentType,\n  path,\n) {\n  // The resolve function's optional fourth argument is a collection of\n  // information about the current execution state.\n  return {\n    fieldName: fieldDef.name,\n    fieldNodes,\n    returnType: fieldDef.type,\n    parentType,\n    path,\n    schema: exeContext.schema,\n    fragments: exeContext.fragments,\n    rootValue: exeContext.rootValue,\n    operation: exeContext.operation,\n    variableValues: exeContext.variableValues,\n  };\n}\n\nfunction handleFieldError(error, returnType, exeContext) {\n  // If the field type is non-nullable, then it is resolved without any\n  // protection from errors, however it still properly locates the error.\n  if (isNonNullType(returnType)) {\n    throw error;\n  } // Otherwise, error protection is applied, logging the error and resolving\n  // a null value for this field if one is encountered.\n\n  exeContext.errors.push(error);\n  return null;\n}\n/**\n * Implements the instructions for completeValue as defined in the\n * \"Value Completion\" section of the spec.\n *\n * If the field type is Non-Null, then this recursively completes the value\n * for the inner type. It throws a field error if that completion returns null,\n * as per the \"Nullability\" section of the spec.\n *\n * If the field type is a List, then this recursively completes the value\n * for the inner type on each item in the list.\n *\n * If the field type is a Scalar or Enum, ensures the completed value is a legal\n * value of the type by calling the `serialize` method of GraphQL type\n * definition.\n *\n * If the field is an abstract type, determine the runtime type of the value\n * and then complete based on that type\n *\n * Otherwise, the field type expects a sub-selection set, and will complete the\n * value by executing all sub-selections.\n */\n\nfunction completeValue(exeContext, returnType, fieldNodes, info, path, result) {\n  // If result is an Error, throw a located error.\n  if (result instanceof Error) {\n    throw result;\n  } // If field type is NonNull, complete for inner type, and throw field error\n  // if result is null.\n\n  if (isNonNullType(returnType)) {\n    const completed = completeValue(\n      exeContext,\n      returnType.ofType,\n      fieldNodes,\n      info,\n      path,\n      result,\n    );\n\n    if (completed === null) {\n      throw new Error(\n        `Cannot return null for non-nullable field ${info.parentType.name}.${info.fieldName}.`,\n      );\n    }\n\n    return completed;\n  } // If result value is null or undefined then return null.\n\n  if (result == null) {\n    return null;\n  } // If field type is List, complete each item in the list with the inner type\n\n  if (isListType(returnType)) {\n    return completeListValue(\n      exeContext,\n      returnType,\n      fieldNodes,\n      info,\n      path,\n      result,\n    );\n  } // If field type is a leaf type, Scalar or Enum, serialize to a valid value,\n  // returning null if serialization is not possible.\n\n  if (isLeafType(returnType)) {\n    return completeLeafValue(returnType, result);\n  } // If field type is an abstract type, Interface or Union, determine the\n  // runtime Object type and complete for that type.\n\n  if (isAbstractType(returnType)) {\n    return completeAbstractValue(\n      exeContext,\n      returnType,\n      fieldNodes,\n      info,\n      path,\n      result,\n    );\n  } // If field type is Object, execute and complete all sub-selections.\n\n  if (isObjectType(returnType)) {\n    return completeObjectValue(\n      exeContext,\n      returnType,\n      fieldNodes,\n      info,\n      path,\n      result,\n    );\n  }\n  /* c8 ignore next 6 */\n  // Not reachable, all possible output types have been considered.\n\n  false ||\n    invariant(\n      false,\n      'Cannot complete value of unexpected output type: ' + inspect(returnType),\n    );\n}\n/**\n * Complete a list value by completing each item in the list with the\n * inner type\n */\n\nfunction completeListValue(\n  exeContext,\n  returnType,\n  fieldNodes,\n  info,\n  path,\n  result,\n) {\n  if (!isIterableObject(result)) {\n    throw new GraphQLError(\n      `Expected Iterable, but did not find one for field \"${info.parentType.name}.${info.fieldName}\".`,\n    );\n  } // This is specified as a simple map, however we're optimizing the path\n  // where the list contains no Promises by avoiding creating another Promise.\n\n  const itemType = returnType.ofType;\n  let containsPromise = false;\n  const completedResults = Array.from(result, (item, index) => {\n    // No need to modify the info object containing the path,\n    // since from here on it is not ever accessed by resolver functions.\n    const itemPath = addPath(path, index, undefined);\n\n    try {\n      let completedItem;\n\n      if (isPromise(item)) {\n        completedItem = item.then((resolved) =>\n          completeValue(\n            exeContext,\n            itemType,\n            fieldNodes,\n            info,\n            itemPath,\n            resolved,\n          ),\n        );\n      } else {\n        completedItem = completeValue(\n          exeContext,\n          itemType,\n          fieldNodes,\n          info,\n          itemPath,\n          item,\n        );\n      }\n\n      if (isPromise(completedItem)) {\n        containsPromise = true; // Note: we don't rely on a `catch` method, but we do expect \"thenable\"\n        // to take a second callback for the error case.\n\n        return completedItem.then(undefined, (rawError) => {\n          const error = locatedError(\n            rawError,\n            fieldNodes,\n            pathToArray(itemPath),\n          );\n          return handleFieldError(error, itemType, exeContext);\n        });\n      }\n\n      return completedItem;\n    } catch (rawError) {\n      const error = locatedError(rawError, fieldNodes, pathToArray(itemPath));\n      return handleFieldError(error, itemType, exeContext);\n    }\n  });\n  return containsPromise ? Promise.all(completedResults) : completedResults;\n}\n/**\n * Complete a Scalar or Enum by serializing to a valid value, returning\n * null if serialization is not possible.\n */\n\nfunction completeLeafValue(returnType, result) {\n  const serializedResult = returnType.serialize(result);\n\n  if (serializedResult == null) {\n    throw new Error(\n      `Expected \\`${inspect(returnType)}.serialize(${inspect(result)})\\` to ` +\n        `return non-nullable value, returned: ${inspect(serializedResult)}`,\n    );\n  }\n\n  return serializedResult;\n}\n/**\n * Complete a value of an abstract type by determining the runtime object type\n * of that value, then complete the value for that type.\n */\n\nfunction completeAbstractValue(\n  exeContext,\n  returnType,\n  fieldNodes,\n  info,\n  path,\n  result,\n) {\n  var _returnType$resolveTy;\n\n  const resolveTypeFn =\n    (_returnType$resolveTy = returnType.resolveType) !== null &&\n    _returnType$resolveTy !== void 0\n      ? _returnType$resolveTy\n      : exeContext.typeResolver;\n  const contextValue = exeContext.contextValue;\n  const runtimeType = resolveTypeFn(result, contextValue, info, returnType);\n\n  if (isPromise(runtimeType)) {\n    return runtimeType.then((resolvedRuntimeType) =>\n      completeObjectValue(\n        exeContext,\n        ensureValidRuntimeType(\n          resolvedRuntimeType,\n          exeContext,\n          returnType,\n          fieldNodes,\n          info,\n          result,\n        ),\n        fieldNodes,\n        info,\n        path,\n        result,\n      ),\n    );\n  }\n\n  return completeObjectValue(\n    exeContext,\n    ensureValidRuntimeType(\n      runtimeType,\n      exeContext,\n      returnType,\n      fieldNodes,\n      info,\n      result,\n    ),\n    fieldNodes,\n    info,\n    path,\n    result,\n  );\n}\n\nfunction ensureValidRuntimeType(\n  runtimeTypeName,\n  exeContext,\n  returnType,\n  fieldNodes,\n  info,\n  result,\n) {\n  if (runtimeTypeName == null) {\n    throw new GraphQLError(\n      `Abstract type \"${returnType.name}\" must resolve to an Object type at runtime for field \"${info.parentType.name}.${info.fieldName}\". Either the \"${returnType.name}\" type should provide a \"resolveType\" function or each possible type should provide an \"isTypeOf\" function.`,\n      fieldNodes,\n    );\n  } // releases before 16.0.0 supported returning `GraphQLObjectType` from `resolveType`\n  // TODO: remove in 17.0.0 release\n\n  if (isObjectType(runtimeTypeName)) {\n    throw new GraphQLError(\n      'Support for returning GraphQLObjectType from resolveType was removed in graphql-js@16.0.0 please return type name instead.',\n    );\n  }\n\n  if (typeof runtimeTypeName !== 'string') {\n    throw new GraphQLError(\n      `Abstract type \"${returnType.name}\" must resolve to an Object type at runtime for field \"${info.parentType.name}.${info.fieldName}\" with ` +\n        `value ${inspect(result)}, received \"${inspect(runtimeTypeName)}\".`,\n    );\n  }\n\n  const runtimeType = exeContext.schema.getType(runtimeTypeName);\n\n  if (runtimeType == null) {\n    throw new GraphQLError(\n      `Abstract type \"${returnType.name}\" was resolved to a type \"${runtimeTypeName}\" that does not exist inside the schema.`,\n      {\n        nodes: fieldNodes,\n      },\n    );\n  }\n\n  if (!isObjectType(runtimeType)) {\n    throw new GraphQLError(\n      `Abstract type \"${returnType.name}\" was resolved to a non-object type \"${runtimeTypeName}\".`,\n      {\n        nodes: fieldNodes,\n      },\n    );\n  }\n\n  if (!exeContext.schema.isSubType(returnType, runtimeType)) {\n    throw new GraphQLError(\n      `Runtime Object type \"${runtimeType.name}\" is not a possible type for \"${returnType.name}\".`,\n      {\n        nodes: fieldNodes,\n      },\n    );\n  }\n\n  return runtimeType;\n}\n/**\n * Complete an Object value by executing all sub-selections.\n */\n\nfunction completeObjectValue(\n  exeContext,\n  returnType,\n  fieldNodes,\n  info,\n  path,\n  result,\n) {\n  // Collect sub-fields to execute to complete this value.\n  const subFieldNodes = collectSubfields(exeContext, returnType, fieldNodes); // If there is an isTypeOf predicate function, call it with the\n  // current result. If isTypeOf returns false, then raise an error rather\n  // than continuing execution.\n\n  if (returnType.isTypeOf) {\n    const isTypeOf = returnType.isTypeOf(result, exeContext.contextValue, info);\n\n    if (isPromise(isTypeOf)) {\n      return isTypeOf.then((resolvedIsTypeOf) => {\n        if (!resolvedIsTypeOf) {\n          throw invalidReturnTypeError(returnType, result, fieldNodes);\n        }\n\n        return executeFields(\n          exeContext,\n          returnType,\n          result,\n          path,\n          subFieldNodes,\n        );\n      });\n    }\n\n    if (!isTypeOf) {\n      throw invalidReturnTypeError(returnType, result, fieldNodes);\n    }\n  }\n\n  return executeFields(exeContext, returnType, result, path, subFieldNodes);\n}\n\nfunction invalidReturnTypeError(returnType, result, fieldNodes) {\n  return new GraphQLError(\n    `Expected value of type \"${returnType.name}\" but got: ${inspect(result)}.`,\n    {\n      nodes: fieldNodes,\n    },\n  );\n}\n/**\n * If a resolveType function is not given, then a default resolve behavior is\n * used which attempts two strategies:\n *\n * First, See if the provided value has a `__typename` field defined, if so, use\n * that value as name of the resolved type.\n *\n * Otherwise, test each possible type for the abstract type by calling\n * isTypeOf for the object being coerced, returning the first type that matches.\n */\n\nexport const defaultTypeResolver = function (\n  value,\n  contextValue,\n  info,\n  abstractType,\n) {\n  // First, look for `__typename`.\n  if (isObjectLike(value) && typeof value.__typename === 'string') {\n    return value.__typename;\n  } // Otherwise, test each possible type.\n\n  const possibleTypes = info.schema.getPossibleTypes(abstractType);\n  const promisedIsTypeOfResults = [];\n\n  for (let i = 0; i < possibleTypes.length; i++) {\n    const type = possibleTypes[i];\n\n    if (type.isTypeOf) {\n      const isTypeOfResult = type.isTypeOf(value, contextValue, info);\n\n      if (isPromise(isTypeOfResult)) {\n        promisedIsTypeOfResults[i] = isTypeOfResult;\n      } else if (isTypeOfResult) {\n        return type.name;\n      }\n    }\n  }\n\n  if (promisedIsTypeOfResults.length) {\n    return Promise.all(promisedIsTypeOfResults).then((isTypeOfResults) => {\n      for (let i = 0; i < isTypeOfResults.length; i++) {\n        if (isTypeOfResults[i]) {\n          return possibleTypes[i].name;\n        }\n      }\n    });\n  }\n};\n/**\n * If a resolve function is not given, then a default resolve behavior is used\n * which takes the property of the source object of the same name as the field\n * and returns it as the result, or if it's a function, returns the result\n * of calling that function while passing along args and context value.\n */\n\nexport const defaultFieldResolver = function (\n  source,\n  args,\n  contextValue,\n  info,\n) {\n  // ensure source is a value for which property access is acceptable.\n  if (isObjectLike(source) || typeof source === 'function') {\n    const property = source[info.fieldName];\n\n    if (typeof property === 'function') {\n      return source[info.fieldName](args, contextValue, info);\n    }\n\n    return property;\n  }\n};\n/**\n * This method looks up the field on the given type definition.\n * It has special casing for the three introspection fields,\n * __schema, __type and __typename. __typename is special because\n * it can always be queried as a field, even in situations where no\n * other fields are allowed, like on a Union. __schema and __type\n * could get automatically added to the query type, but that would\n * require mutating type definitions, which would cause issues.\n *\n * @internal\n */\n\nexport function getFieldDef(schema, parentType, fieldNode) {\n  const fieldName = fieldNode.name.value;\n\n  if (\n    fieldName === SchemaMetaFieldDef.name &&\n    schema.getQueryType() === parentType\n  ) {\n    return SchemaMetaFieldDef;\n  } else if (\n    fieldName === TypeMetaFieldDef.name &&\n    schema.getQueryType() === parentType\n  ) {\n    return TypeMetaFieldDef;\n  } else if (fieldName === TypeNameMetaFieldDef.name) {\n    return TypeNameMetaFieldDef;\n  }\n\n  return parentType.getFields()[fieldName];\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgCA;;;;CAIC,GAED,MAAM,mBAAmB,wIAAS,CAAC,YAAY,YAAY,aACzD,uJACE,WAAW,MAAM,EACjB,WAAW,SAAS,EACpB,WAAW,cAAc,EACzB,YACA;AAwCG,SAAS,QAAQ,IAAI;IAC1B,oDAAoD;IACpD,UAAU,MAAM,GAAG,KACjB,0IACE,OACA;IAEJ,MAAM,EAAE,MAAM,EAAE,QAAQ,EAAE,cAAc,EAAE,SAAS,EAAE,GAAG,MAAM,yDAAyD;IAEvH,8BAA8B,QAAQ,UAAU,iBAAiB,6EAA6E;IAC9I,6CAA6C;IAE7C,MAAM,aAAa,sBAAsB,OAAO,mDAAmD;IAEnG,IAAI,CAAC,CAAC,YAAY,UAAU,GAAG;QAC7B,OAAO;YACL,QAAQ;QACV;IACF,EAAE,yEAAyE;IAC3E,uDAAuD;IACvD,EAAE;IACF,uEAAuE;IACvE,2EAA2E;IAC3E,2EAA2E;IAC3E,oBAAoB;IACpB,EAAE;IACF,2EAA2E;IAC3E,yEAAyE;IACzE,uCAAuC;IAEvC,IAAI;QACF,MAAM,EAAE,SAAS,EAAE,GAAG;QACtB,MAAM,SAAS,iBAAiB,YAAY,WAAW;QAEvD,IAAI,0IAAU,SAAS;YACrB,OAAO,OAAO,IAAI,CAChB,CAAC,OAAS,cAAc,MAAM,WAAW,MAAM,GAC/C,CAAC;gBACC,WAAW,MAAM,CAAC,IAAI,CAAC;gBACvB,OAAO,cAAc,MAAM,WAAW,MAAM;YAC9C;QAEJ;QAEA,OAAO,cAAc,QAAQ,WAAW,MAAM;IAChD,EAAE,OAAO,OAAO;QACd,WAAW,MAAM,CAAC,IAAI,CAAC;QACvB,OAAO,cAAc,MAAM,WAAW,MAAM;IAC9C;AACF;AAOO,SAAS,YAAY,IAAI;IAC9B,MAAM,SAAS,QAAQ,OAAO,6CAA6C;IAE3E,IAAI,0IAAU,SAAS;QACrB,MAAM,IAAI,MAAM;IAClB;IAEA,OAAO;AACT;AACA;;;CAGC,GAED,SAAS,cAAc,IAAI,EAAE,MAAM;IACjC,OAAO,OAAO,MAAM,KAAK,IACrB;QACE;IACF,IACA;QACE;QACA;IACF;AACN;AAQO,SAAS,8BACd,MAAM,EACN,QAAQ,EACR,iBAAiB;IAEjB,YAAY,0IAAU,OAAO,2BAA2B,+DAA+D;IAEvH,8IAAkB,SAAS,6CAA6C;IAExE,qBAAqB,QACnB,gJAAa,sBACb,0IACE,OACA;AAEN;AAUO,SAAS,sBAAsB,IAAI;IACxC,IAAI,kBAAkB;IAEtB,MAAM,EACJ,MAAM,EACN,QAAQ,EACR,SAAS,EACT,YAAY,EACZ,gBAAgB,iBAAiB,EACjC,aAAa,EACb,aAAa,EACb,YAAY,EACZ,sBAAsB,EACvB,GAAG;IACJ,IAAI;IACJ,MAAM,YAAY,OAAO,MAAM,CAAC;IAEhC,KAAK,MAAM,cAAc,SAAS,WAAW,CAAE;QAC7C,OAAQ,WAAW,IAAI;YACrB,KAAK,kIAAK,oBAAoB;gBAC5B,IAAI,iBAAiB,MAAM;oBACzB,IAAI,cAAc,WAAW;wBAC3B,OAAO;4BACL,kJACE;yBAEH;oBACH;oBAEA,YAAY;gBACd,OAAO,IACL,CAAC,CAAC,mBAAmB,WAAW,IAAI,MAAM,QAC1C,qBAAqB,KAAK,IACtB,KAAK,IACL,iBAAiB,KAAK,MAAM,eAChC;oBACA,YAAY;gBACd;gBAEA;YAEF,KAAK,kIAAK,mBAAmB;gBAC3B,SAAS,CAAC,WAAW,IAAI,CAAC,KAAK,CAAC,GAAG;gBACnC;YAEF;QACF;IACF;IAEA,IAAI,CAAC,WAAW;QACd,IAAI,iBAAiB,MAAM;YACzB,OAAO;gBAAC,kJAAiB,CAAC,yBAAyB,EAAE,cAAc,EAAE,CAAC;aAAE;QAC1E;QAEA,OAAO;YAAC,kJAAiB;SAA8B;IACzD,EAAE,2DAA2D;IAE7D,kBAAkB,GAElB,MAAM,sBACJ,CAAC,wBAAwB,UAAU,mBAAmB,MAAM,QAC5D,0BAA0B,KAAK,IAC3B,wBACA,EAAE;IACR,MAAM,wBAAwB,iJAC5B,QACA,qBACA,sBAAsB,QAAQ,sBAAsB,KAAK,IACrD,oBACA,CAAC,GACL;QACE,WAAW;IACb;IAGF,IAAI,sBAAsB,MAAM,EAAE;QAChC,OAAO,sBAAsB,MAAM;IACrC;IAEA,OAAO;QACL;QACA;QACA;QACA;QACA;QACA,gBAAgB,sBAAsB,OAAO;QAC7C,eACE,kBAAkB,QAAQ,kBAAkB,KAAK,IAC7C,gBACA;QACN,cACE,iBAAiB,QAAQ,iBAAiB,KAAK,IAC3C,eACA;QACN,wBACE,2BAA2B,QAAQ,2BAA2B,KAAK,IAC/D,yBACA;QACN,QAAQ,EAAE;IACZ;AACF;AACA;;CAEC,GAED,SAAS,iBAAiB,UAAU,EAAE,SAAS,EAAE,SAAS;IACxD,MAAM,WAAW,WAAW,MAAM,CAAC,WAAW,CAAC,UAAU,SAAS;IAElE,IAAI,YAAY,MAAM;QACpB,MAAM,kJACJ,CAAC,oCAAoC,EAAE,UAAU,SAAS,CAAC,WAAW,CAAC,EACvE;YACE,OAAO;QACT;IAEJ;IAEA,MAAM,aAAa,oJACjB,WAAW,MAAM,EACjB,WAAW,SAAS,EACpB,WAAW,cAAc,EACzB,UACA,UAAU,YAAY;IAExB,MAAM,OAAO;IAEb,OAAQ,UAAU,SAAS;QACzB,KAAK,6IAAkB,KAAK;YAC1B,OAAO,cAAc,YAAY,UAAU,WAAW,MAAM;QAE9D,KAAK,6IAAkB,QAAQ;YAC7B,OAAO,sBACL,YACA,UACA,WACA,MACA;QAGJ,KAAK,6IAAkB,YAAY;YACjC,sDAAsD;YACtD,4EAA4E;YAC5E,OAAO,cAAc,YAAY,UAAU,WAAW,MAAM;IAChE;AACF;AACA;;;CAGC,GAED,SAAS,sBACP,UAAU,EACV,UAAU,EACV,WAAW,EACX,IAAI,EACJ,MAAM;IAEN,OAAO,kJACL,OAAO,OAAO,IACd,CAAC;YAAS,CAAC,cAAc,WAAW;QAClC,MAAM,YAAY,mIAAQ,MAAM,cAAc,WAAW,IAAI;QAC7D,MAAM,SAAS,aACb,YACA,YACA,aACA,YACA;QAGF,IAAI,WAAW,WAAW;YACxB,OAAO;QACT;QAEA,IAAI,0IAAU,SAAS;YACrB,OAAO,OAAO,IAAI,CAAC,CAAC;gBAClB,OAAO,CAAC,aAAa,GAAG;gBACxB,OAAO;YACT;QACF;QAEA,OAAO,CAAC,aAAa,GAAG;QACxB,OAAO;IACT,GACA,OAAO,MAAM,CAAC;AAElB;AACA;;;CAGC,GAED,SAAS,cAAc,UAAU,EAAE,UAAU,EAAE,WAAW,EAAE,IAAI,EAAE,MAAM;IACtE,MAAM,UAAU,OAAO,MAAM,CAAC;IAC9B,IAAI,kBAAkB;IAEtB,IAAI;QACF,KAAK,MAAM,CAAC,cAAc,WAAW,IAAI,OAAO,OAAO,GAAI;YACzD,MAAM,YAAY,mIAAQ,MAAM,cAAc,WAAW,IAAI;YAC7D,MAAM,SAAS,aACb,YACA,YACA,aACA,YACA;YAGF,IAAI,WAAW,WAAW;gBACxB,OAAO,CAAC,aAAa,GAAG;gBAExB,IAAI,0IAAU,SAAS;oBACrB,kBAAkB;gBACpB;YACF;QACF;IACF,EAAE,OAAO,OAAO;QACd,IAAI,iBAAiB;YACnB,0FAA0F;YAC1F,OAAO,wJAAiB,SAAS,OAAO,CAAC;gBACvC,MAAM;YACR;QACF;QAEA,MAAM;IACR,EAAE,0DAA0D;IAE5D,IAAI,CAAC,iBAAiB;QACpB,OAAO;IACT,EAAE,8EAA8E;IAChF,6EAA6E;IAC7E,6EAA6E;IAE7E,OAAO,wJAAiB;AAC1B;AACA;;;;;CAKC,GAED,SAAS,aAAa,UAAU,EAAE,UAAU,EAAE,MAAM,EAAE,UAAU,EAAE,IAAI;IACpE,IAAI;IAEJ,MAAM,WAAW,YAAY,WAAW,MAAM,EAAE,YAAY,UAAU,CAAC,EAAE;IAEzE,IAAI,CAAC,UAAU;QACb;IACF;IAEA,MAAM,aAAa,SAAS,IAAI;IAChC,MAAM,YACJ,CAAC,oBAAoB,SAAS,OAAO,MAAM,QAC3C,sBAAsB,KAAK,IACvB,oBACA,WAAW,aAAa;IAC9B,MAAM,OAAO,iBACX,YACA,UACA,YACA,YACA,OACC,qFAAqF;IAExF,IAAI;QACF,yEAAyE;QACzE,sDAAsD;QACtD,yEAAyE;QACzE,MAAM,OAAO,iJACX,UACA,UAAU,CAAC,EAAE,EACb,WAAW,cAAc,GACxB,yEAAyE;QAC5E,4EAA4E;QAC5E,uEAAuE;QAEvE,MAAM,eAAe,WAAW,YAAY;QAC5C,MAAM,SAAS,UAAU,QAAQ,MAAM,cAAc;QACrD,IAAI;QAEJ,IAAI,0IAAU,SAAS;YACrB,YAAY,OAAO,IAAI,CAAC,CAAC,WACvB,cAAc,YAAY,YAAY,YAAY,MAAM,MAAM;QAElE,OAAO;YACL,YAAY,cACV,YACA,YACA,YACA,MACA,MACA;QAEJ;QAEA,IAAI,0IAAU,YAAY;YACxB,uEAAuE;YACvE,gDAAgD;YAChD,OAAO,UAAU,IAAI,CAAC,WAAW,CAAC;gBAChC,MAAM,QAAQ,8IAAa,UAAU,YAAY,uIAAY;gBAC7D,OAAO,iBAAiB,OAAO,YAAY;YAC7C;QACF;QAEA,OAAO;IACT,EAAE,OAAO,UAAU;QACjB,MAAM,QAAQ,8IAAa,UAAU,YAAY,uIAAY;QAC7D,OAAO,iBAAiB,OAAO,YAAY;IAC7C;AACF;AAKO,SAAS,iBACd,UAAU,EACV,QAAQ,EACR,UAAU,EACV,UAAU,EACV,IAAI;IAEJ,qEAAqE;IACrE,iDAAiD;IACjD,OAAO;QACL,WAAW,SAAS,IAAI;QACxB;QACA,YAAY,SAAS,IAAI;QACzB;QACA;QACA,QAAQ,WAAW,MAAM;QACzB,WAAW,WAAW,SAAS;QAC/B,WAAW,WAAW,SAAS;QAC/B,WAAW,WAAW,SAAS;QAC/B,gBAAgB,WAAW,cAAc;IAC3C;AACF;AAEA,SAAS,iBAAiB,KAAK,EAAE,UAAU,EAAE,UAAU;IACrD,qEAAqE;IACrE,uEAAuE;IACvE,IAAI,4IAAc,aAAa;QAC7B,MAAM;IACR,EAAE,0EAA0E;IAC5E,qDAAqD;IAErD,WAAW,MAAM,CAAC,IAAI,CAAC;IACvB,OAAO;AACT;AACA;;;;;;;;;;;;;;;;;;;;CAoBC,GAED,SAAS,cAAc,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,IAAI,EAAE,IAAI,EAAE,MAAM;IAC3E,gDAAgD;IAChD,IAAI,kBAAkB,OAAO;QAC3B,MAAM;IACR,EAAE,2EAA2E;IAC7E,qBAAqB;IAErB,IAAI,4IAAc,aAAa;QAC7B,MAAM,YAAY,cAChB,YACA,WAAW,MAAM,EACjB,YACA,MACA,MACA;QAGF,IAAI,cAAc,MAAM;YACtB,MAAM,IAAI,MACR,CAAC,0CAA0C,EAAE,KAAK,UAAU,CAAC,IAAI,CAAC,CAAC,EAAE,KAAK,SAAS,CAAC,CAAC,CAAC;QAE1F;QAEA,OAAO;IACT,EAAE,yDAAyD;IAE3D,IAAI,UAAU,MAAM;QAClB,OAAO;IACT,EAAE,4EAA4E;IAE9E,IAAI,yIAAW,aAAa;QAC1B,OAAO,kBACL,YACA,YACA,YACA,MACA,MACA;IAEJ,EAAE,4EAA4E;IAC9E,mDAAmD;IAEnD,IAAI,yIAAW,aAAa;QAC1B,OAAO,kBAAkB,YAAY;IACvC,EAAE,uEAAuE;IACzE,kDAAkD;IAElD,IAAI,6IAAe,aAAa;QAC9B,OAAO,sBACL,YACA,YACA,YACA,MACA,MACA;IAEJ,EAAE,oEAAoE;IAEtE,IAAI,2IAAa,aAAa;QAC5B,OAAO,oBACL,YACA,YACA,YACA,MACA,MACA;IAEJ;IACA,oBAAoB,GACpB,iEAAiE;IAEjE,SACE,0IACE,OACA,sDAAsD,sIAAQ;AAEpE;AACA;;;CAGC,GAED,SAAS,kBACP,UAAU,EACV,UAAU,EACV,UAAU,EACV,IAAI,EACJ,IAAI,EACJ,MAAM;IAEN,IAAI,CAAC,wJAAiB,SAAS;QAC7B,MAAM,kJACJ,CAAC,mDAAmD,EAAE,KAAK,UAAU,CAAC,IAAI,CAAC,CAAC,EAAE,KAAK,SAAS,CAAC,EAAE,CAAC;IAEpG,EAAE,uEAAuE;IACzE,4EAA4E;IAE5E,MAAM,WAAW,WAAW,MAAM;IAClC,IAAI,kBAAkB;IACtB,MAAM,mBAAmB,MAAM,IAAI,CAAC,QAAQ,CAAC,MAAM;QACjD,yDAAyD;QACzD,oEAAoE;QACpE,MAAM,WAAW,mIAAQ,MAAM,OAAO;QAEtC,IAAI;YACF,IAAI;YAEJ,IAAI,0IAAU,OAAO;gBACnB,gBAAgB,KAAK,IAAI,CAAC,CAAC,WACzB,cACE,YACA,UACA,YACA,MACA,UACA;YAGN,OAAO;gBACL,gBAAgB,cACd,YACA,UACA,YACA,MACA,UACA;YAEJ;YAEA,IAAI,0IAAU,gBAAgB;gBAC5B,kBAAkB,MAAM,uEAAuE;gBAC/F,gDAAgD;gBAEhD,OAAO,cAAc,IAAI,CAAC,WAAW,CAAC;oBACpC,MAAM,QAAQ,8IACZ,UACA,YACA,uIAAY;oBAEd,OAAO,iBAAiB,OAAO,UAAU;gBAC3C;YACF;YAEA,OAAO;QACT,EAAE,OAAO,UAAU;YACjB,MAAM,QAAQ,8IAAa,UAAU,YAAY,uIAAY;YAC7D,OAAO,iBAAiB,OAAO,UAAU;QAC3C;IACF;IACA,OAAO,kBAAkB,QAAQ,GAAG,CAAC,oBAAoB;AAC3D;AACA;;;CAGC,GAED,SAAS,kBAAkB,UAAU,EAAE,MAAM;IAC3C,MAAM,mBAAmB,WAAW,SAAS,CAAC;IAE9C,IAAI,oBAAoB,MAAM;QAC5B,MAAM,IAAI,MACR,CAAC,WAAW,EAAE,sIAAQ,YAAY,WAAW,EAAE,sIAAQ,QAAQ,OAAO,CAAC,GACrE,CAAC,qCAAqC,EAAE,sIAAQ,kBAAkB,CAAC;IAEzE;IAEA,OAAO;AACT;AACA;;;CAGC,GAED,SAAS,sBACP,UAAU,EACV,UAAU,EACV,UAAU,EACV,IAAI,EACJ,IAAI,EACJ,MAAM;IAEN,IAAI;IAEJ,MAAM,gBACJ,CAAC,wBAAwB,WAAW,WAAW,MAAM,QACrD,0BAA0B,KAAK,IAC3B,wBACA,WAAW,YAAY;IAC7B,MAAM,eAAe,WAAW,YAAY;IAC5C,MAAM,cAAc,cAAc,QAAQ,cAAc,MAAM;IAE9D,IAAI,0IAAU,cAAc;QAC1B,OAAO,YAAY,IAAI,CAAC,CAAC,sBACvB,oBACE,YACA,uBACE,qBACA,YACA,YACA,YACA,MACA,SAEF,YACA,MACA,MACA;IAGN;IAEA,OAAO,oBACL,YACA,uBACE,aACA,YACA,YACA,YACA,MACA,SAEF,YACA,MACA,MACA;AAEJ;AAEA,SAAS,uBACP,eAAe,EACf,UAAU,EACV,UAAU,EACV,UAAU,EACV,IAAI,EACJ,MAAM;IAEN,IAAI,mBAAmB,MAAM;QAC3B,MAAM,kJACJ,CAAC,eAAe,EAAE,WAAW,IAAI,CAAC,uDAAuD,EAAE,KAAK,UAAU,CAAC,IAAI,CAAC,CAAC,EAAE,KAAK,SAAS,CAAC,eAAe,EAAE,WAAW,IAAI,CAAC,2GAA2G,CAAC,EAC/Q;IAEJ,EAAE,oFAAoF;IACtF,iCAAiC;IAEjC,IAAI,2IAAa,kBAAkB;QACjC,MAAM,kJACJ;IAEJ;IAEA,IAAI,OAAO,oBAAoB,UAAU;QACvC,MAAM,kJACJ,CAAC,eAAe,EAAE,WAAW,IAAI,CAAC,uDAAuD,EAAE,KAAK,UAAU,CAAC,IAAI,CAAC,CAAC,EAAE,KAAK,SAAS,CAAC,OAAO,CAAC,GACxI,CAAC,MAAM,EAAE,sIAAQ,QAAQ,YAAY,EAAE,sIAAQ,iBAAiB,EAAE,CAAC;IAEzE;IAEA,MAAM,cAAc,WAAW,MAAM,CAAC,OAAO,CAAC;IAE9C,IAAI,eAAe,MAAM;QACvB,MAAM,kJACJ,CAAC,eAAe,EAAE,WAAW,IAAI,CAAC,0BAA0B,EAAE,gBAAgB,wCAAwC,CAAC,EACvH;YACE,OAAO;QACT;IAEJ;IAEA,IAAI,CAAC,2IAAa,cAAc;QAC9B,MAAM,kJACJ,CAAC,eAAe,EAAE,WAAW,IAAI,CAAC,qCAAqC,EAAE,gBAAgB,EAAE,CAAC,EAC5F;YACE,OAAO;QACT;IAEJ;IAEA,IAAI,CAAC,WAAW,MAAM,CAAC,SAAS,CAAC,YAAY,cAAc;QACzD,MAAM,kJACJ,CAAC,qBAAqB,EAAE,YAAY,IAAI,CAAC,8BAA8B,EAAE,WAAW,IAAI,CAAC,EAAE,CAAC,EAC5F;YACE,OAAO;QACT;IAEJ;IAEA,OAAO;AACT;AACA;;CAEC,GAED,SAAS,oBACP,UAAU,EACV,UAAU,EACV,UAAU,EACV,IAAI,EACJ,IAAI,EACJ,MAAM;IAEN,wDAAwD;IACxD,MAAM,gBAAgB,iBAAiB,YAAY,YAAY,aAAa,+DAA+D;IAC3I,wEAAwE;IACxE,6BAA6B;IAE7B,IAAI,WAAW,QAAQ,EAAE;QACvB,MAAM,WAAW,WAAW,QAAQ,CAAC,QAAQ,WAAW,YAAY,EAAE;QAEtE,IAAI,0IAAU,WAAW;YACvB,OAAO,SAAS,IAAI,CAAC,CAAC;gBACpB,IAAI,CAAC,kBAAkB;oBACrB,MAAM,uBAAuB,YAAY,QAAQ;gBACnD;gBAEA,OAAO,cACL,YACA,YACA,QACA,MACA;YAEJ;QACF;QAEA,IAAI,CAAC,UAAU;YACb,MAAM,uBAAuB,YAAY,QAAQ;QACnD;IACF;IAEA,OAAO,cAAc,YAAY,YAAY,QAAQ,MAAM;AAC7D;AAEA,SAAS,uBAAuB,UAAU,EAAE,MAAM,EAAE,UAAU;IAC5D,OAAO,kJACL,CAAC,wBAAwB,EAAE,WAAW,IAAI,CAAC,WAAW,EAAE,sIAAQ,QAAQ,CAAC,CAAC,EAC1E;QACE,OAAO;IACT;AAEJ;AAYO,MAAM,sBAAsB,SACjC,KAAK,EACL,YAAY,EACZ,IAAI,EACJ,YAAY;IAEZ,gCAAgC;IAChC,IAAI,gJAAa,UAAU,OAAO,MAAM,UAAU,KAAK,UAAU;QAC/D,OAAO,MAAM,UAAU;IACzB,EAAE,sCAAsC;IAExC,MAAM,gBAAgB,KAAK,MAAM,CAAC,gBAAgB,CAAC;IACnD,MAAM,0BAA0B,EAAE;IAElC,IAAK,IAAI,IAAI,GAAG,IAAI,cAAc,MAAM,EAAE,IAAK;QAC7C,MAAM,OAAO,aAAa,CAAC,EAAE;QAE7B,IAAI,KAAK,QAAQ,EAAE;YACjB,MAAM,iBAAiB,KAAK,QAAQ,CAAC,OAAO,cAAc;YAE1D,IAAI,0IAAU,iBAAiB;gBAC7B,uBAAuB,CAAC,EAAE,GAAG;YAC/B,OAAO,IAAI,gBAAgB;gBACzB,OAAO,KAAK,IAAI;YAClB;QACF;IACF;IAEA,IAAI,wBAAwB,MAAM,EAAE;QAClC,OAAO,QAAQ,GAAG,CAAC,yBAAyB,IAAI,CAAC,CAAC;YAChD,IAAK,IAAI,IAAI,GAAG,IAAI,gBAAgB,MAAM,EAAE,IAAK;gBAC/C,IAAI,eAAe,CAAC,EAAE,EAAE;oBACtB,OAAO,aAAa,CAAC,EAAE,CAAC,IAAI;gBAC9B;YACF;QACF;IACF;AACF;AAQO,MAAM,uBAAuB,SAClC,MAAM,EACN,IAAI,EACJ,YAAY,EACZ,IAAI;IAEJ,oEAAoE;IACpE,IAAI,gJAAa,WAAW,OAAO,WAAW,YAAY;QACxD,MAAM,WAAW,MAAM,CAAC,KAAK,SAAS,CAAC;QAEvC,IAAI,OAAO,aAAa,YAAY;YAClC,OAAO,MAAM,CAAC,KAAK,SAAS,CAAC,CAAC,MAAM,cAAc;QACpD;QAEA,OAAO;IACT;AACF;AAaO,SAAS,YAAY,MAAM,EAAE,UAAU,EAAE,SAAS;IACvD,MAAM,YAAY,UAAU,IAAI,CAAC,KAAK;IAEtC,IACE,cAAc,oJAAmB,IAAI,IACrC,OAAO,YAAY,OAAO,YAC1B;QACA;IACF,OAAO,IACL,cAAc,kJAAiB,IAAI,IACnC,OAAO,YAAY,OAAO,YAC1B;QACA;IACF,OAAO,IAAI,cAAc,sJAAqB,IAAI,EAAE;QAClD;IACF;IAEA,OAAO,WAAW,SAAS,EAAE,CAAC,UAAU;AAC1C"}},
    {"offset": {"line": 811, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 815, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/graphql/execution/mapAsyncIterator.mjs"],"sourcesContent":["/**\n * Given an AsyncIterable and a callback function, return an AsyncIterator\n * which produces values mapped via calling the callback function.\n */\nexport function mapAsyncIterator(iterable, callback) {\n  const iterator = iterable[Symbol.asyncIterator]();\n\n  async function mapResult(result) {\n    if (result.done) {\n      return result;\n    }\n\n    try {\n      return {\n        value: await callback(result.value),\n        done: false,\n      };\n    } catch (error) {\n      /* c8 ignore start */\n      // FIXME: add test case\n      if (typeof iterator.return === 'function') {\n        try {\n          await iterator.return();\n        } catch (_e) {\n          /* ignore error */\n        }\n      }\n\n      throw error;\n      /* c8 ignore stop */\n    }\n  }\n\n  return {\n    async next() {\n      return mapResult(await iterator.next());\n    },\n\n    async return() {\n      // If iterator.return() does not exist, then type R must be undefined.\n      return typeof iterator.return === 'function'\n        ? mapResult(await iterator.return())\n        : {\n            value: undefined,\n            done: true,\n          };\n    },\n\n    async throw(error) {\n      if (typeof iterator.throw === 'function') {\n        return mapResult(await iterator.throw(error));\n      }\n\n      throw error;\n    },\n\n    [Symbol.asyncIterator]() {\n      return this;\n    },\n  };\n}\n"],"names":[],"mappings":"AAAA;;;CAGC;;;AACM,SAAS,iBAAiB,QAAQ,EAAE,QAAQ;IACjD,MAAM,WAAW,QAAQ,CAAC,OAAO,aAAa,CAAC;IAE/C,eAAe,UAAU,MAAM;QAC7B,IAAI,OAAO,IAAI,EAAE;YACf,OAAO;QACT;QAEA,IAAI;YACF,OAAO;gBACL,OAAO,MAAM,SAAS,OAAO,KAAK;gBAClC,MAAM;YACR;QACF,EAAE,OAAO,OAAO;YACd,mBAAmB,GACnB,uBAAuB;YACvB,IAAI,OAAO,SAAS,MAAM,KAAK,YAAY;gBACzC,IAAI;oBACF,MAAM,SAAS,MAAM;gBACvB,EAAE,OAAO,IAAI;gBACX,gBAAgB,GAClB;YACF;YAEA,MAAM;QACN,kBAAkB,GACpB;IACF;IAEA,OAAO;QACL,MAAM;YACJ,OAAO,UAAU,MAAM,SAAS,IAAI;QACtC;QAEA,MAAM;YACJ,sEAAsE;YACtE,OAAO,OAAO,SAAS,MAAM,KAAK,aAC9B,UAAU,MAAM,SAAS,MAAM,MAC/B;gBACE,OAAO;gBACP,MAAM;YACR;QACN;QAEA,MAAM,OAAM,KAAK;YACf,IAAI,OAAO,SAAS,KAAK,KAAK,YAAY;gBACxC,OAAO,UAAU,MAAM,SAAS,KAAK,CAAC;YACxC;YAEA,MAAM;QACR;QAEA,CAAC,OAAO,aAAa,CAAC;YACpB,OAAO,IAAI;QACb;IACF;AACF"}},
    {"offset": {"line": 865, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 869, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/graphql/execution/subscribe.mjs"],"sourcesContent":["import { devAssert } from '../jsutils/devAssert.mjs';\nimport { inspect } from '../jsutils/inspect.mjs';\nimport { isAsyncIterable } from '../jsutils/isAsyncIterable.mjs';\nimport { addPath, pathToArray } from '../jsutils/Path.mjs';\nimport { GraphQLError } from '../error/GraphQLError.mjs';\nimport { locatedError } from '../error/locatedError.mjs';\nimport { collectFields } from './collectFields.mjs';\nimport {\n  assertValidExecutionArguments,\n  buildExecutionContext,\n  buildResolveInfo,\n  execute,\n  getFieldDef,\n} from './execute.mjs';\nimport { mapAsyncIterator } from './mapAsyncIterator.mjs';\nimport { getArgumentValues } from './values.mjs';\n/**\n * Implements the \"Subscribe\" algorithm described in the GraphQL specification.\n *\n * Returns a Promise which resolves to either an AsyncIterator (if successful)\n * or an ExecutionResult (error). The promise will be rejected if the schema or\n * other arguments to this function are invalid, or if the resolved event stream\n * is not an async iterable.\n *\n * If the client-provided arguments to this function do not result in a\n * compliant subscription, a GraphQL Response (ExecutionResult) with\n * descriptive errors and no data will be returned.\n *\n * If the source stream could not be created due to faulty subscription\n * resolver logic or underlying systems, the promise will resolve to a single\n * ExecutionResult containing `errors` and no `data`.\n *\n * If the operation succeeded, the promise resolves to an AsyncIterator, which\n * yields a stream of ExecutionResults representing the response stream.\n *\n * Accepts either an object with named arguments, or individual arguments.\n */\n\nexport async function subscribe(args) {\n  // Temporary for v15 to v16 migration. Remove in v17\n  arguments.length < 2 ||\n    devAssert(\n      false,\n      'graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead.',\n    );\n  const resultOrStream = await createSourceEventStream(args);\n\n  if (!isAsyncIterable(resultOrStream)) {\n    return resultOrStream;\n  } // For each payload yielded from a subscription, map it over the normal\n  // GraphQL `execute` function, with `payload` as the rootValue.\n  // This implements the \"MapSourceToResponseEvent\" algorithm described in\n  // the GraphQL specification. The `execute` function provides the\n  // \"ExecuteSubscriptionEvent\" algorithm, as it is nearly identical to the\n  // \"ExecuteQuery\" algorithm, for which `execute` is also used.\n\n  const mapSourceToResponse = (payload) =>\n    execute({ ...args, rootValue: payload }); // Map every source value to a ExecutionResult value as described above.\n\n  return mapAsyncIterator(resultOrStream, mapSourceToResponse);\n}\n\nfunction toNormalizedArgs(args) {\n  const firstArg = args[0];\n\n  if (firstArg && 'document' in firstArg) {\n    return firstArg;\n  }\n\n  return {\n    schema: firstArg,\n    // FIXME: when underlying TS bug fixed, see https://github.com/microsoft/TypeScript/issues/31613\n    document: args[1],\n    rootValue: args[2],\n    contextValue: args[3],\n    variableValues: args[4],\n    operationName: args[5],\n    subscribeFieldResolver: args[6],\n  };\n}\n/**\n * Implements the \"CreateSourceEventStream\" algorithm described in the\n * GraphQL specification, resolving the subscription source event stream.\n *\n * Returns a Promise which resolves to either an AsyncIterable (if successful)\n * or an ExecutionResult (error). The promise will be rejected if the schema or\n * other arguments to this function are invalid, or if the resolved event stream\n * is not an async iterable.\n *\n * If the client-provided arguments to this function do not result in a\n * compliant subscription, a GraphQL Response (ExecutionResult) with\n * descriptive errors and no data will be returned.\n *\n * If the the source stream could not be created due to faulty subscription\n * resolver logic or underlying systems, the promise will resolve to a single\n * ExecutionResult containing `errors` and no `data`.\n *\n * If the operation succeeded, the promise resolves to the AsyncIterable for the\n * event stream returned by the resolver.\n *\n * A Source Event Stream represents a sequence of events, each of which triggers\n * a GraphQL execution for that event.\n *\n * This may be useful when hosting the stateful subscription service in a\n * different process or machine than the stateless GraphQL execution engine,\n * or otherwise separating these two steps. For more on this, see the\n * \"Supporting Subscriptions at Scale\" information in the GraphQL specification.\n */\n\nexport async function createSourceEventStream(...rawArgs) {\n  const args = toNormalizedArgs(rawArgs);\n  const { schema, document, variableValues } = args; // If arguments are missing or incorrectly typed, this is an internal\n  // developer mistake which should throw an early error.\n\n  assertValidExecutionArguments(schema, document, variableValues); // If a valid execution context cannot be created due to incorrect arguments,\n  // a \"Response\" with only errors is returned.\n\n  const exeContext = buildExecutionContext(args); // Return early errors if execution context failed.\n\n  if (!('schema' in exeContext)) {\n    return {\n      errors: exeContext,\n    };\n  }\n\n  try {\n    const eventStream = await executeSubscription(exeContext); // Assert field returned an event stream, otherwise yield an error.\n\n    if (!isAsyncIterable(eventStream)) {\n      throw new Error(\n        'Subscription field must return Async Iterable. ' +\n          `Received: ${inspect(eventStream)}.`,\n      );\n    }\n\n    return eventStream;\n  } catch (error) {\n    // If it GraphQLError, report it as an ExecutionResult, containing only errors and no data.\n    // Otherwise treat the error as a system-class error and re-throw it.\n    if (error instanceof GraphQLError) {\n      return {\n        errors: [error],\n      };\n    }\n\n    throw error;\n  }\n}\n\nasync function executeSubscription(exeContext) {\n  const { schema, fragments, operation, variableValues, rootValue } =\n    exeContext;\n  const rootType = schema.getSubscriptionType();\n\n  if (rootType == null) {\n    throw new GraphQLError(\n      'Schema is not configured to execute subscription operation.',\n      {\n        nodes: operation,\n      },\n    );\n  }\n\n  const rootFields = collectFields(\n    schema,\n    fragments,\n    variableValues,\n    rootType,\n    operation.selectionSet,\n  );\n  const [responseName, fieldNodes] = [...rootFields.entries()][0];\n  const fieldDef = getFieldDef(schema, rootType, fieldNodes[0]);\n\n  if (!fieldDef) {\n    const fieldName = fieldNodes[0].name.value;\n    throw new GraphQLError(\n      `The subscription field \"${fieldName}\" is not defined.`,\n      {\n        nodes: fieldNodes,\n      },\n    );\n  }\n\n  const path = addPath(undefined, responseName, rootType.name);\n  const info = buildResolveInfo(\n    exeContext,\n    fieldDef,\n    fieldNodes,\n    rootType,\n    path,\n  );\n\n  try {\n    var _fieldDef$subscribe;\n\n    // Implements the \"ResolveFieldEventStream\" algorithm from GraphQL specification.\n    // It differs from \"ResolveFieldValue\" due to providing a different `resolveFn`.\n    // Build a JS object of arguments from the field.arguments AST, using the\n    // variables scope to fulfill any variable references.\n    const args = getArgumentValues(fieldDef, fieldNodes[0], variableValues); // The resolve function's optional third argument is a context value that\n    // is provided to every resolve function within an execution. It is commonly\n    // used to represent an authenticated user, or request-specific caches.\n\n    const contextValue = exeContext.contextValue; // Call the `subscribe()` resolver or the default resolver to produce an\n    // AsyncIterable yielding raw payloads.\n\n    const resolveFn =\n      (_fieldDef$subscribe = fieldDef.subscribe) !== null &&\n      _fieldDef$subscribe !== void 0\n        ? _fieldDef$subscribe\n        : exeContext.subscribeFieldResolver;\n    const eventStream = await resolveFn(rootValue, args, contextValue, info);\n\n    if (eventStream instanceof Error) {\n      throw eventStream;\n    }\n\n    return eventStream;\n  } catch (error) {\n    throw locatedError(error, fieldNodes, pathToArray(path));\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1004, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1008, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 1029, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}